<!DOCTYPE html>
<!--
since you're here anyway: there's a small easter egg on the text commands page but it's probably not worth finding, sorry
you may notice this page's code is garbage: i'm not a web designer! ;-;
it's w3c valid, at least
-->

<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="favicon.ico">

    <title>UNITALE Documentation</title>
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap-theme.min.css" rel="stylesheet">
    <link href="css/themesidebar.css" rel="stylesheet">
    <link href="css/shThemeRDark.css" rel="stylesheet">

    <!-- Syntax highlighting -->
    <script type="text/javascript" src="js/shCore.js"></script>
    <script type="text/javascript" src="js/shBrushLua.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
<img src="img/bg2.png" alt="Undertale background" class="backimg">
<div class="container arena black">
    <div class="col-md-2">
        <!--navigation-->
        <nav class="nav-sidebar">
            <ul class="nav tabs">
                <li class="li-header">Basics</li>
                    <li class="active"><a href="#welcome" data-toggle="tab">Welcome</a></li>
                    <li><a href="#howtoreadthisdocumentation" data-toggle="tab">How to read this documentation</a></li>
                    <li><a href="#controls" data-toggle="tab">Controls</a></li>
                    <li><a href="#basic" data-toggle="tab">Basic setup</a></li>
                    <li><a href="#terms" data-toggle="tab">Terminology</a></li>
                <li class="li-header">API</li>
                    <li><a href="#api-text" data-toggle="tab">Text commands</a></li>
                    <li><a href="#api-events" data-toggle="tab">Game events</a></li>
                    <li class="li-indent">Functions &amp; Objects</li>
                        <li class="li-indent"><a href="#api-functions-main" data-toggle="tab">Misc. Functions</a></li>
                        <li class="li-indent"><a href="#api-functions-player" data-toggle="tab">The Player Object</a></li>
                        <li class="li-indent"><a href="#api-functions-script" data-toggle="tab">The Script Object</a></li>
                        <li class="li-indent"><a href="#api-functions-audio" data-toggle="tab">The Audio Object</a></li>
                        <li class="li-indent"><a href="#api-functions-newaudio" data-toggle="tab"><span class="CYF"></span>The NewAudio Object</a></li>
                        <li class="li-indent"><a href="#api-functions-input" data-toggle="tab">The Input Object</a></li>
                        <li class="li-indent"><a href="#api-functions-time" data-toggle="tab">The Time Object</a></li>
                        <li class="li-indent"><a href="#api-functions-misc" data-toggle="tab"><span class="CYF"></span>The Misc Object</a></li>
                        <li class="li-indent"><a href="#api-functions-waves" data-toggle="tab">Wave Scripts</a></li>
                    <li><a href="#api-projectile" data-toggle="tab">Projectile management</a></li>
                    <li><a href="#api-animation" data-toggle="tab">Sprites &amp; Animation</a></li>
                    <li><a href="#api-keys" data-toggle="tab"><span class="CYF"></span> Key List</a></li>
                <li class="li-header">Create Your Frisk's new features</li>		
                    <li><a href="#cyf-inventory" data-toggle="tab"><span class="CYF"></span> The Inventory System</a></li>
                    <li><a href="#cyf-ppcollision" data-toggle="tab"><span class="CYF"></span> The Pixel-Perfect Collision System</a></li>
                    <li><a href="#cyf-text" data-toggle="tab"><span class="CYF"></span> The Text Object</a></li>
                <li class="li-header">Resources</li>
                    <li><a href="media/dialogoptions.png">Dialog bubble names</a></li>
            </ul>
        </nav>
    </div>
    <!--tabs'n'shit-->
    <div class="tab-content col-md-10">
        <div class="tab-pane active text-style" id="welcome">
            <h2>Welcome to Create Your Frisk's documentation!</h2><br><br>
            
            <p><span style="color:#aa0000">NOTE:</span> There will be casual <span style="color:#aa0000">spoilers</span>
                all over the place. If you haven't played or completed Undertale yet, it's highly recommended that you do
                so first! Don't say you weren't warned.
				<br><br>
                You probably want to get right in, so let's keep it short. Honestly, the fastest way to get started is
                to check out the existing encounters and tinker with them. The documentation is for reference if you
                want to know the specifics of everything. Help is provided on the 
                <a href="http://www.reddit.com/r/Unitale">/r/Unitale subreddit</a>.
                <br><br>
				<span style="color:#aa0000"><u>FOR CYF COMPATIBILITY:</u></span> You have to add these two lines in the 
				<span class="term">EncounterStarting()</span> function:
				<div class="code-container">
				<pre class="brush: lua;">
				Inventory.AddCustomItems({"Dogtest1", "Dogtest2", "Dogtest3", "Dogtest4", "Dogtest5", "Dogtest6", "Dogtest7"}, {3, 3, 3, 3, 3, 3, 3})
				Inventory.SetInventory({"Dogtest1", "Dogtest2", "Dogtest3", "Dogtest4", "Dogtest5", "Dogtest6", "Dogtest7"})
				</pre>
				</div>
				<br>Of course, if your encounter already uses an item system, you have to replace the names and the effects.
				<br>0 for consumable, 1 for weapon, 2 for armor and 3 for special
				<br><br>
				<span style="color:#aa0000"><u>FOR BACKWARD COMPATIBILITY:</u></span> You can use the retromode in the modDev mode.
                It's not perfect, but it's better than nothing, I guess.
				<br><br>
                <i><u>Basic setup</u></i><br>
                Details folder structure of mods, how the game reads folders and expects files, that kind of stuff.
                Recommended to start with.<br>
                <br>
                <i><u>Terminology</u></i><br>
                This is a short page on how what things are called in the documentation. For instance, the white box
                that the bullet dodging occurs in is referred to as the &quot;arena&quot;. Recommended read so you don't
                get lost in later parts of the documentation.<br>
                <br>
                <i><u>API - Text commands</u></i><br>
                This is where all the special commands are that you can use in your dialogue boxes. Text effects,
                colours, character voices, automatic skipping, you name it. You can even add commands to run Lua
                code!<br>
                <br>
                <i><u>API - Game events</u></i><br>
                If you want to get your hands dirty with Lua, these are the functions the game will use from your
                script, and at what point they're used. Useful for if you want to have certain events occur during
                specific times, such as before/after using an act command or item, or just before the fight starts. A
                must-read for interactive fights.<br>
                <br>
                <i><u>API - Functions &amp; Objects</u></i><br>
                These are most custom functions and objects that you can use in your scripts, detailing how to use them
                and what they do. Want to control the music, check for game events or handle keyboard input? Global
                variables so you can communicate between scripts? Need to know how much HP the player has, damage them,
                heal them? This is where to go! Projectile management and sprite management are split off into separate
                sections below.<br>
                <br>
                <i><u>API - Projectile management</u></i><br>
                This is where you can read details about how to create projectiles, what you can do with them and some
                short examples.<br>
                <br>
                <i><u>API - Sprites &amp; Animation</u></i><br>
                This section is about creating sprites and how to control them. By combining the sprite functions, you
                can create animations.<br>
                <br>
                <i><u><span class="CYF"></span> API - Key List</u></i><br>
                This section shows you the list of keys available for <span class="term">Input.GetKey(key)</span> and <span class="term">[waitfor:key]</span>.
				<br>
                <br>
                <i><u><span class="CYF"></span> Added features</u></i><br>
                Pretty exhaustive list of things that I added in CYF. However, you know me: some things may be forgotten.<br>
                <br>
                <i><u><span class="CYF"></span> The Inventory System</u></i><br>
                This section shows you how CYF's Inventory System works. Get rid of the dogtests! <br>
                <br>
                <i><u><span class="CYF"></span> The Pixel-Perfect Collision System</u></i><br>
                This section shows you how CYF's Pixel-Perfect Collision System works. Why would you use square hitboxes when
				you have a system like this?
            </p>
        </div>
       
        <div class="tab-pane text-style" id="howtoreadthisdocumentation">
            <h2>How to read this documentation</h2><br><br>
            <p>After people had some problems reading the documentation correctly, I decided to create this little tutorial.</p>
            <p>Let's say you saw something in the documentation that looks like this:</p>
            <p><span class="term">
			<!-- <div class="code-container"> -->
			<!-- <pre class="brush: lua"> -->
			Screen.DispImg(string path, int ID, float posX, float posY, int toneR = 255, int toneG = 255, int toneB = 255, int toneA = 255)
			<!-- </pre> -->
			<!-- </div> -->
			</span></p>
            <p>There are several things to know here. First of all, the arguments have a type and a name. The name really is here just to help you to know 
			what the variable is,
               you don't really have to care about it. However, the type is important, it determines what kind of variable you'll need to send.<br>
               <br>In this example, "string" is a character chain (i.e. "hello"), "int" is an integer (i.e. 4) and "float" is a number (i.e. 3.6 or -2.) </p>
            <p>One last thing with functions: some of these arguments have a value after them - this is the variable's default value. So, you can
               use the function without including that argument.<br>
               In our example, that means that you can call just <span class="term">Screen.DispImg("poseur", 1, 320, 240)</span> - but you can add the 
			   other values if you want to add them.<br>
               However, if you need to set <span class="term">toneB</span> in our example, you need to set <span class="term">toneR</span> and <span class=
			   "term">toneG</span> before it, as well. If you want to keep the default values, just enter these :P<br>
               <br>So if we want to fully call this function and set <span class="term">toneA</span> to 255, we have to call it like this: <br><div class=
			   "code-container"><pre class="brush: lua">Screen.DispImg("poseur", 1, 320, 240, 255, 255, 255, 255)</pre></div></p>
            <p>Finally, if you're a fan of Unitale and want to use it instead of CYF, but still want to use this documentation, note this: all the variables 
			or functions with this tag: <span class="CYF"></span> are only usable in CYF.</p>
            <p>Now that you know how to read the documentation, you should keep reading! It'd be too bad if you stopped now :P</p>
        </div>

        <div class="tab-pane text-style" id="controls">
            <h2>Controls</h2><br><br>
            <p><span class="term">Arrow keys, Z (or Enter), X (or left/right Shift)</span> - The same as in Undertale.
            </p>
            <p><span class="term">Esc</span> - Resets to the Mod Selection screen to assist in quickly testing mods.
                Will not work on the disclaimer screen. <span class="CYF"></span>: disabled if the encounter has "<span class="term">unescape</span>" set 
				to true</p>
            <p><span class="term">F9</span> - Toggles the debug console. You can write text to this with
                <span class="term">DEBUG("your text here")</span> in your scripts.</p>
            <p><span class="term">Alt+Enter</span> - Fullscreens the game. <span class="term">F4</span> works too, but not on the disclaimer/Game
                Over screens.</p>
			<p><span class="CYF"></span> <span class="term">H</span> - In a battle, this shows the hitboxes of the bullets and the player.</p>
        </div>

        <div class="tab-pane text-style" id="basic">
            <h2>Basic setup</h2><br><br>
            <p>IMPORTANT NOTE: Due to the hasty implementation of file loading, your encounter will currently break if
                certain folders are missing. To make sure this doesn't happen, please preserve the folder structure of
                the example mods, <i>even if you have no files in a certain folder.</i> It's an early alpha and we're
                working on it!</p>

            <p>By this point you'll probably want to set up an encounter of your own. Right now, we only have encounters
                implemented, and even that's still a work in progress! Currently, scripts are set up like this:</p>
            <ul>
                <li>Monster scripts - will contain information about your enemies. Here, you'll set things like their
                    ATK, DEF, HP, random comments that might show up as encounter texts, random dialogue, and what ACT
                    commands they have.
                </li><br>
                <li>Encounter scripts - will contain a set of monsters, a set of wave scripts (that you can modify at
                    any point), size of the arena, custom interactions for items, etc. <br>
                    A lot of Unitale's functions will be run on the Encounter scripts first. If there's no custom
                    behaviour on the encounter, many of these functions will then also be run on the Monster scripts.
                    More information on this can be found in the <span class="ref">API - Game events</span> section.
                </li><br>
                <li>Wave scripts - will contain an update function. You may use these to spawn, track, modify and
                    otherwise interact with bullets during the defending phase of the game.
                </li><br>
            </ul>
            <p>Eventually, you will be able to call up your encounter scripts from various places in the overworld.
                The current version of the game lets you select which encounter you
                want to play.</p>
            <hr>
            <h3>Files and directories</h3><br><br>
            <p>It's fairly self-explanatory. If you just want to move on fast, feel free to skip this section and go to
                the next one. If for any reason some of your files don't work, you might want to read this anyway.</p>
            <h4>Scripts</h4>
            <p>The <i>Encounter scripts</i> are located in <span class="term"><i>YOUR MOD/Lua/Encounters/</i></span>. The <i>Monster scripts</i>
                are in <span class="term"><i>YOUR MOD/Lua/Monsters/</i></span>, and your wave scripts at <span class="term"><i>YOUR MOD/Lua/Waves/</i></span>. If you're
                getting started, check out these files in example encounters to see how they're put together. Starting
                from 0.2, there's also an optional <span class="term"><i>YOUR MOD/Lua/Libraries/</i></span> folder. You can put libraries other
                people have made in here (or create your own) for use in your other scripts. Libraries/modules are more
                Lua functionality than they are Unitale functionality, so please read up about them <a
                        href="http://lua-users.org/wiki/ModulesTutorial">here</a> instead. There is an example encounter
                included making use of one such library. Plus, the overworld permits you to have <i>Event scripts</i>
                located in <span class="term"><i>YOURMOD/Lua/Events/</i></span> if you want to use the overworld.</p>
            <h4>Music</h4>
            <p>Music can be put in <span class="term"><i>YOUR MOD/Audio/</i></span>. Your music must be in .ogg or .wav format. <a
                    href="http://audacityteam.org/download/">Audacity</a> can export to .ogg if you're missing the
                appropriate software.</p>
            <h4>Sounds</h4>
            <p>Sounds can be put in <span class="term"><i>YOUR MOD/Sounds/</i></span>. They must be in .ogg or .wav format. You can play them with
                <span class="term">Audio.PlaySound(filename)</span>; more on this in <span class="ref">API - Functions &amp; Objects</span>.</p>
            <h4>Voices</h4>
            <p>Voices can be put in <span class="term"><i>YOUR MOD/Voices/</i></span>. They must be in .ogg or .wav format, although .wav is
                generally recommended. You can use them with the <span class="term">[voice]</span> text command; more on this in <span class="ref">API - Text
                    commands</span>.</p>
            <h4>Sprites</h4>
            <p>Sprites can be put in <span class="term"><i>YOUR MOD/Sprites/</i></span>. They must be in the .png format. Note that most vanilla
                Undertale monster sprites start with a small base resolution, then resize the sprite to 2x its original
                resolution for an oldschool look. To <i>add a background</i> you can have one file titled <span class="term">bg.png</span>
                in the sprites folder. This image will stretch over the entire background, so 640x480 resolution is
                recommended. This is <i>not</i> the final solution for backgrounds; it just beats not having one.</p>
            <hr>
            <h3>The Default directory</h3><br><br>
            <p>Starting from 0.2 Unitale now has a default directory. This is where resources from Undertale reside. It
                is not advised to modify files in this directory, as they are expected to be the same across all
                installations. <br><br>If you wish to replace any of the files for your mod, create a file with the same
                name at the same location instead. For instance, if you want to change the player soul hurt sound, don't
                replace <span class="term">Default/Sounds/hurtsound.wav</span>. Instead, create a new file located at <span class="term"><i>YOUR
                    MOD/Sounds/hurtsound.wav</i></span>.</p>
            <hr>
            <h3>Basic variables and their usage</h3><br><br>
            <p>Now that all of that's out of the way, it's time to set up the basics of an encounter! The fastest way to
                get started is to copy the 'Encounter Skeleton' mod and play with the values in it, then either copying
                over existing examples' code, or writing your own. This section serves to explain the variables you
                see.</p>
            <h4>Encounter script variables</h4>
            <div class="code-container">
<pre class="brush: lua;">music = "yourmusicname_without_extension"
encountertext = "Vegetoid came out of\rthe earth!"
nextwaves = {"bullettest_wavy", "bullettest_homing"}
wavetimer = 4.0
arenasize = {155, 130}

enemies = { "vegetoid" }

enemypositions = {
{0, 50},
{-70, 30},
{70, 30}
}

</pre>
            </div>
            <p><span class="term">music</span> - Name of your encounter's starting music, without the file extension. If this variable isn't
                present, it'll play Undertale's default battle theme. If you don't want any music, call
                <span class="term">Audio.Stop()</span> in the <span class="term">EncounterStarting()</span> function. For more information see <span class="ref">API - Game
                    events</span>.</p>
            <p><span class="term">encountertext</span> - Set the initial text of your encounter here. After that, you can modify it at any time in
                preparation for the next turn. <span class="term">encountertext</span> gets read out at the start of every new turn (i.e.
                you going back to the FIGHT/ACT/ITEM/MERCY selection).</p>
            <p><span class="term">nextwaves</span> - A list of all simultaneous attack waves you want when the monsters start their attacks. You
                can modify this at any time, and it'll get read out before the enemies start their attack. For most
                boss-type encounters, you'll likely only want one wave simultaneously - but you can get creative
                here.</p>
            <p><span class="term">wavetimer</span> - How long it takes for the defending step to end. If this isn't set anywhere, it'll be the
                default <i>4.0 seconds</i>.</p>
            <p><span class="term">arenasize</span> - The inner size of the box the player's constrained to. <span class="term">{155, 130}</span> is the default size for a
                lot of basic Undertale encounters. Papyrus' battle, for instance, has this at <span class="term">{245, 130}</span> most of the
                time. You may modify this at any time - it'll only get read out before the enemies start their
                attack.<br>
                Note: lowest possible setting is <span class="term">{16, 16}</span> - this is the size of the player's soul. Anything lower will
                be set to 16 anyway.</p>
            <p><span class="term">enemies</span> - Defines the names of your enemy scripts that will be used in your encounter. In this example.
                <span class="term">vegetoid.lua</span> will be used from the Monsters folder. After initialization, the names will be
                replaced by Script controller objects you can use to control your monster scripts. Refer to <span class="ref">API -
                    Functions &amp; Objects</span> for more information.</p>
            <p><span class="term">enemypositions</span> - Defines where the enemies are on the screen. <span class="term">{0, 0}</span> means they're centered just above the arena, with 1 pixel of space inbetween. <span class="term">{-30, 0}</span> means above the arena to the left; <span class="term">{50, 80}</span> means 50 pixels to the right and 80 pixels above that center.<br>
                You will always need at least as many enemy positions as enemies in your encounter. In this example we
                have 3 enemy positions set to show you how you can define more than one, but since this example only
                contains Vegetoid you only really need one position.</p>
			<p><span class="CYF"></span> <span class="term">autolinebreak</span> - False by default. If this value is set to
                true, the auto linebreak system will automatically add line breaks (<span class="term">\r</span>) to the text. No need to use <span class="term">\r</span> or <span class="term">\n</span> anymore!</p>
			<p><span class="CYF"></span> <span class="term">playerskipdocommand</span> - False by default. If this value is
                set to true, the text commands will be launched even if the player skips the text-  except for <span class="term">[w]</span> and
                <span class="term">[letters]</span> commands and commands with the tag "<span class="term">skipover</span>".</p>
			<p><span class="CYF"></span> <span class="term">unescape</span> - False by default. If this value is set to true, you can't exit the battle with the ESC
				key anymore.</p>
			<p><span class="CYF"></span> <span class="term">flee</span> - True by default. If this value is set to false, the flee option will not be selectable anymore.</p>
			<p><span class="CYF"></span> <span class="term">revive</span> - If this variable is set to true, the player will be revived when they hit 0 HP.</p>
			<p><span class="CYF"></span> <span class="term">deathtext</span> - Text displayed when the player dies, in the Game Over screen. By default, it'll use the normal death text.<br>
			Is used as the revive text too. By default, there will be no revive text.</p>
			<p><span class="CYF"></span> <span class="term">deathmusic</span> - Sets the death music. The music is launched if <span class="term">revive</span> is not set.</p>
			<p><span class="CYF"></span> <span class="term">Wave</span> - A table returning the current wave scripts used. Returns a table with a length of 0 if not in the state DEFENDING.</p>
			
            <hr>
            <h4>Monster script variables</h4>
            <div class="code-container">
<pre class="brush: lua;">comments = {"Vegetoid cackles softly.", "Vegetoid's here for your health."}
commands = {"Talk", "Devour", "Dinner"}
randomdialogue = {"Fresh\nMorning\nTaste", "Farmed\nLocally,\nVery\nLocally"}
currentdialogue = {'Eat\nYour\nGreens'}
cancheck = true
canspare = false

sprite = "vegetoid_sprite"
dialogbubble = "rightshort"
name = "Vegetoid"
hp = 20
atk = 6
def = 6
xp = 6
gold = 1
check = "Serving Size: 1 Monster\nNot monitored by the USDA"</pre>
            </div>
            <p><span class="term">comments</span> - A list of random comments attached to this monster. You can retrieve one at random using the
                <span class="term">RandomEncounterText()</span> function in your Encounter script. See <span class="ref">API - Functions &amp; Objects</span> for
                details.</p>
            <p><span class="term">commands</span> - A list of ACT commands you can do. Listed in the ACT menu and used in <span class="term">HandleCustomCommand()</span>.
                See <span class="ref">API - Game events</span> for details. Note that the behaviour for Check is built-in, and shows you
                the monster's <span class="term">name</span> followed by the <span class="term">ATK</span> and <span class="term">DEF</span>, and then the <span class="term">check</span> variable
                you'll see all the way down.</p>
            <p><span class="term">randomdialogue</span> - A list of random dialogue the monster can have. One of these is selected at random if
                <span class="term">currentdialogue</span> is <span class="term">nil</span> (i.e. has no value).</p>
            <p><span class="term">currentdialogue</span> - The next dialogue for this monster. This overrides the random dialogue and is meant for
                special actions (e.g. you hit Vegetoid's green carrots after selecting Dinner from the ACT menu). This
                variable gets <i>cleared every time after it's read out in the monster dialogue phase</i>. This is done
                so you don't have to take care of managing it manually.</p>
            <p><span class="term">cancheck</span> - Either true or false. You can leave this line out; it will be true by default. If set to
                false, it will disable the default Check action that shows up in your ACT menu. If you want a custom
                Check action, you can add it back into your <span class="term">commands</span> table, and handle it like any other custom
                command. See <span class="ref">API - Game events</span> for details.</p>
            <p><span class="term">canspare</span> - Either true or false. If you leave this line out, it'll be set to false by default. If you
                change this to true, your monster's name will turn yellow and it will be spareable.</p>
            <br>
            <p><span class="term">sprite</span> - Name of the sprite in your Sprites folder, without the .PNG extension. This is the initial
                sprite for your monster. It can be changed using <span class="term">SetSprite(name)</span>; see <span class="ref">API - Functions &amp; Objects</span> for details.</p>
            <p><span class="CYF"></span> <span class="term">monstersprite</span> - Sprite handler of the monster.</p>
            <p><span class="term">dialogbubble</span> - What dialogue bubble will be used for the monster's dialogue. You can change this at any
                time, but this <i>must</i> be initially set to something. For a list of all possible options, check the
                <a href="media/dialogoptions.png">dialog bubble names</a> chart; it's also in the sidebar.
                Positioning of the bubbles is done automatically.</p>
            <p><span class="term">name</span> - Monster name. Fairly self-explanatory; shows up in the FIGHT/ACT menus. Can also be changed at any
                time.</p>
            <p><span class="term">hp</span> - Your monster's max HP, initially. After the fight has started this value will always accurately
                reflect your monster's current HP. You can then modify this value to change your monster's current
                HP.</p>
            <p><span class="CYF"></span> <span class="term">maxhp</span> - Your monster's max HP. After the fight has started this value will be always the same, unless you
			change it. It is mainly used for lifebars and such. You better not set it as 0 or as a negative number,
			though.</p>
            <p><span class="term">atk</span> - Your monster's ATK. Only used in the default Check handler; bullet damage is set through wave
                scripts. If you're not using the default Check you can leave this out.</p>
            <p><span class="term">def</span> - Your monster's DEF.</p>
            <p><span class="term">xp</span> - Your monster's XP upon actually defeating them. You only get this by killing the monster.</p>
            <p><span class="term">gold</span> - Gold you get from either killing or sparing this monster. Since the gold can change based on
                whether you kill or spare the monster, you can modify this at any time up until the fight ends.</p>
            <p><span class="term">check</span> - When checking with the default Check option, this is what's listed under the monster's name, ATK
                and DEF.</p>
            <p><span class="CYF"></span> <span class="term">unkillable</span> - Set it to true and the monster will not be killed if it has less than 1 HP. However, it can
				still be killed with <span class="term">Kill()</span>.</p>
			<p><span class="CYF"></span> <span class="term">canmove</span> - The enemies need some initialization frames to place themselves correctly, so you can't move or unbind the
				enemy's sprite if those haven't finished. True if you can move the sprite, otherwise it's false. Actually, now that the battle's launch is delayed, this value
                is deprecated as it'll always be true.</p>
			<p><span class="CYF"></span> <span class="term">posx</span> - The x position of the center of the enemy's sprite.</p>
			<p><span class="CYF"></span> <span class="term">posy</span> - The y position of the bottom of the enemy's sprite.</p>
			<p><span class="CYF"></span> <span class="term">font</span> - The default font used by the monster. Set it to nil if you want to use the normal monster font.</p>
			<p><span class="CYF"></span> <span class="term">voice</span> - The default voice used by the monster. Set it to nil if you want to use the default voice.</p>
            <hr>
           
            <h4>Wave script variables</h4>
            <p>Wave scripts don't have any variables that are read out from the start, but you can define your own. An
                instance of a wave script is made when you start defending, and is destroyed when the defending step
                ends. As such, you can't store variables in a wave script for reusing later. Use the Encounter script to
                keep track of things.</p>
        </div>

        <div class="tab-pane text-style" id="terms">
            <h2>Terminology</h2><br><br>
            <p><span class="term">arena</span> - The inside of the white box in which the player is allowed to move.</p>
            <p><span class="term">bullet</span> - Everything in a wave that can collide with you. Flowey's pellets would
                be referred to as bullets, but so would Papyrus' bones, anything Woshua can shoot (of any colour), even
                the dancing Migosp.</p>
            <p><span class="term">encounter text</span> - The text that shows up before you've selected FIGHT/ACT/ITEM/MERCY.</p>
            <p><span class="term">monster dialogue</span> - Text from monsters in an encounter, often seen before
                attacking. Can also be multiple dialogue boxes for special encounters.</p>
            <p><span class="term">dialog</span> - A user interface component that contains text. For example, the battle
                dialog window. The distinction between "dialog" and "dialogue" is that "dialog" refers to interface windows
                containing text, and "dialogue" refers to the speech content of monsters.</p>
            <p><span class="term">wave</span> - A single attack behaviour (or attack "wave", to say), measured from when
                you start defending until when it stops. Vegetoid's bouncing vegetables attack would count as a wave.
                Papyrus' special Cool Dude attack would also count as a wave. Unitale works with "wave scripts" for
                attacks; you can use multiple wave scripts at the same time for when you have various monsters.</p>
			<p><span class="CYF"></span> <span class="term">overworld</span> - A CYF feature that is external to battles. It allows
				the user to explore maps, like in Undertale. The overworld can contain event objects, too.<br>You can find a tutorial
				on maps in <span class="ref">How to create a map</span> and a tutorial on events is in <span class="ref">How
				to create an event</span>.
				</p>
			<p><span class="CYF"></span> <span class="term">modDev</span> - This is a feature exclusive to CYF. It's the
				same as the mod selection screen in Unitale, but with some extra debug tools. For instance, this screen lets you reset
				all <span class="term">real globals</span> and <span class="term">AlMighty globals</span>. It also allows you to
				enable or disable <span class="term">safe mode</span> and <span class="term">retrocompatibilty mode</span>.</p>
			<p><span class="CYF"></span> <span class="term">retrocompatibilty mode</span> - This CYF feature is designed in such
				a way where, if it's enabled, functions from 0.2.1a that were changed in CYF will function exactly as they did
				in 0.2.1a.</p>
			<p><span class="CYF"></span> <span class="term">safe mode</span> - This is a CYF-mode that removes swear words found
				in CYF. Mod authors can also use this to do the same in their mods, maybe even also using this to remove blood
				or mature content.</p>
        </div>

        <div class="tab-pane text-style" id="api-text">
            <h2>Text commands</h2><br><br>
            <p>There are <b>two types</b> of text commands: commands that get executed <u>instantly</u>, like text color
                and effects; and commands that get executed <u>inline</u>, as they're displayed, like wait commands and
                character voices. Note that currently, if you skip a text command (with X), it'll also skip all inline
                commands that were still in your text.<span class="CYF"></span> <i>Unless</i>, that is, you use <span class="term">playerskipdocommand</span> :P</p>

            <p>On line breaks: there are actually two different kinds. In <i>UI messages</i> where asterisks are used,
                you can use <span class="term">\n</span> to start a new line <i>with</i> an asterisk. If you want a new line <i>without</i>
                an asterisk, use <span class="term">\r</span>.</p>

            <p>This is different for monster dialogue that isn't prefixed with asterisks: <i>Always</i> use <span class="term">\n</span> for line
                breaks here.<span class="CYF"></span> Or use <span class="term">autolinebreak</span>! See <span class="ref">Basic Setup</span>.</p>

            <h3>Instant commands</h3><br>
            <p class="exblock">
                <br><span class="function">[color:rrggbb]</span>
                This sets the text color for all text after this command to the specified hex code. It resets per
                dialogue. <span class="term">[color:ff0000]</span> would be red, <span class="term">[color:555555]</span> a dark grey. Here are a few 
				examples:</p>
            <table class="table">
                <tr>
                    <td><span class="term">[color:ff0000]</span></td>
                    <td><span style="color:#ff0000">Determination</span></td>
                </tr>
                <tr>
                    <td><span class="term">[color:003cff]</span></td>
                    <td><span style="color:#003cff">Integrity</span></td>
                </tr>
                <tr>
                    <td><span class="term">[color:00c000]</span></td>
                    <td><span style="color:#00c000">Kindness</span></td>
                </tr>
                <tr>
                    <td><span class="term">[color:ffff00]</span></td>
                    <td><span style="color:#ffff00">Justice</span></td>
                </tr>
                <tr>
                    <td><span class="term">[color:d535d9]</span></td>
                    <td><span style="color:#d535d9">Perseverance</span></td>
                </tr>
                <tr>
                    <td><span class="term">[color:fca600]</span></td>
                    <td><span style="color:#fca600">Bravery</span></td>
                </tr>
                <tr>
                    <td><span class="term">[color:42fcff]</span></td>
                    <td><span style="color:#42fcff">Patience</span></td>
                </tr>
            </table>
            <p class="exblock">
                If you have to use colours, try to stick to these. While the option for any colour is offered, actual
                usage in Undertale is very limited.<br>
                <br>
                The default UI text is plain white and the default enemy dialogue text is plain black - <span class="term">[color:ffffff]</span>
                and <span class="term">[color:000000]</span> respectively.
            </p>

            <p class="exblock">
                <br><span class="function">[starcolor:rrggbb]</span>
                Same usage as color but <i>only affects the first asterisk in a dialogue box that has asterisks.</i>
                This is a dirty workaround, but now you don't need it anymore, it's deprecated.<br>
				<span class="CYF"></span> As commands are now executed before the star, you can use <span class="term">[color]</span> to color the star.
            </p>

            <p class="exblock">
                <br><span class="function">[instant]</span>
                Instantly shows the entire text without having to wait or press anything.
            </p>

            <p class="exblock">
                <br><span class="function">[effect:x] or [effect:x,intensity]</span>
                Sets the text effect for <i>the entire message, regardless of position</i>. You can use the following
                effects:</p>
            <ul>
                <li><span class="term">none</span>: No effect on the text.</li><br>
                <li><span class="term">rotate</span>: Rotating text, most random monsters have this by default. Intensity sets how far letters
                    rotate, in pixels. Default is 1.5.
                </li><br>
                <li><span class="term">shake</span>: Shaking text. Flowey uses this sometimes. Intensity sets how far the letters offset, in
                    pixels. Default is 1.0.
                </li><br>
                <li><span class="term">twitch</span>: Letters twitch occasionally - the battle UI has this by default. Intensity sets how far a letter
                    should shake. Default is 2.0.
                </li><br>
            </ul>
            <p class="exblock">
                Note that the twitch effect should, at a later point, let you set shake frequency. Unfortunately you
                can't do this yet.
            </p>

            <p class="exblock">
                <br><span class="function">[font:x]</span>
                Sets the font for this dialogue. Usually includes a default voice. As the <span class="term">[font]</span> command can change both
                text colour and voice, if you want to have your own voice/text color do it after the font change.
                Possible options:</p>
            <ul>
                <li><span class="term">uidialog</span>: Default large pixel font for UI.</li><br>
                <li><span class="term">monster</span>: Default font for almost all monsters in the game.</li><br>
                <li><span class="term">sans</span>: sans. use lowercase. uppercase works, but... sans.</li><br>
                <li><span class="term">papyrus</span>: PAPYRUS! USE UPPERCASE ONLY. LOWERCASE WON'T WORK.</li><br>
                <li><span class="term">wingdings</span>: Wingdings.</li><br>
                <li><span class="term">uibattlesmall</span>: The font used for the character name, HP and level.</li><br>
                <li>and a lot of others...you can even create your own font!</li><br>
            </ul>
            <p>For all default fonts, check out the <span class="term">Default/Sprites/UI/Fonts</span> folder. Every font with a matching .xml
                file is mapped.</p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[charspacing:number]</span>
                Number of pixels that separates the characters on the same line.
            </p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[linespacing:number]</span>
                Shift of the number of pixels that separates characters on different lines. Negative = upper, Positive = lower
            </p>

            <h3>Inline commands</h3><br>

            <p class="exblock">
                <br><span class="function">[noskip]</span>
                Prevents this dialogue from being skipped by pressing X. Has no effect in encounter texts as you don't
                control that. Is effective only at the moment it's launched, so if you want a text to not be skippable at the beginning, use it as
                the very first command of your text.
            </p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[noskip:off]</span>
                Cancels a previously launched <span class="term">[noskip]</span> command.
            </p>
           
            <p class="exblock">
                <br><span class="function">[w:x]</span>
                The wait command. This will pause your textbox for x frames.
            </p>

            <p class="exblock">
                <br><span class="function">[waitall:x]</span>
                Like the wait command, but applies to all letters after this command. It resets per dialogue. Useful for
                slow text.
            </p>

            <p class="exblock">
                <br><span class="function">[voice:filename]</span>
                Sets the voice (sound per letter) to a sound located in <span class="term">YOUR MOD/Sounds/Voices</span>. Applies to all letters
                after the command. It resets per dialogue. This has to be a .wav file, and you shouldn't include the
                file extension when using <span class="term">[voice]</span>. If your voice sound is <span class="term">YOUR MOD/Sounds/Voices/mettaton.wav</span>, you can
                use it with <span class="term">[voice:mettaton]</span>.<br>
                <span class="term">[voice:default]</span> resets to the default voice (beeps). If you have a voice sound named 'default', it will
                be ignored.</p>

            <p class="exblock">
                <br><span class="function">[novoice]</span>
                Removes the voice for the letters after this command. It resets per dialogue.
				<span style="color:#000">Useful for when you should be burning in hell.</span>
                <br><span class="function">[next]</span>
                Skips to the next dialogue automatically. You can also use this for textbox trickery. Here's an example
                to replicate Flowey's text-changing effect if you dodge the Friendliness Pellets(tm) twice.
            </p>
            <div class="code-container">
   <pre class="brush: lua;">first line:  "[noskip][voice:flowey][effect:none]RUN. [w:30]INTO. [w:30]THE.\n[w:30]BULLETS!![w:30][next]"
second line: "[instant][effect:none]RUN. INTO. THE.\nfriendliness\npellets"</pre>
            </div>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[finished]</span>
                Sets this dialogue box as "finished". To go through the next dialogue box, you'll have to wait until the other
				monsters' dialogue boxes are also finished.
            </p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[nextthisnow]</span>
                Skips to the next dialogue of all monsters automatically, without concern for the other monsters' dialogue's state.
            </p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[waitfor:key]</span>
                Waits for the user to press the given key to continue the message.
				Check the <span class="ref">Key List</span> to see the available keys.
            </p>

            <p class="exblock">
                <br><span class="function">[func:x], [func:x,argument] <span class="CYF"></span>or [func:x,{argument1, argument2...}]</span>
                The most powerful command. If the previous text commands were established official characters, [func] is
                some kid's deviantArt original character that never dies and has all the superpowers.<br>
                <br>
                In all seriousness, <span class="term">[func]</span> allows you to execute <i>any function from your script in line with the
                text</i>. Refer to the examples below.</p>
            <div class="code-container">
   <pre class="brush: lua;">your dialogue: "hoi hoi this is dog [func:dog] and now the music changed"
  
function dog()
	Audio.LoadFile("dog_music")
	--plays dog_music.ogg (or .wav) from your Audio folder! for built-in functions like this, refer to section API - Functions &amp; Objects
	--insert more code here, any code!
end</pre>
            </div>

            <div class="code-container">
   <pre class="brush: lua;">your dialogue: "dog with arguments!! [func:newmusic,temietheme] so intense!"
  
function newmusic(yourargumentname)
	Audio.LoadFile(yourargumentname) --with this example, it'll load 'temietheme.ogg (or .wav)'...
	--and then play it! THE FUTURE IS NOW! By using an argument, your function can be more versatile.
end</pre>
            </div>
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[speed:x]</span>
                Makes the text box show x characters per frame instead of the usual 1 per frame.
            </p>
           
            <p class="exblock">
            <br><span class="function"><span class="CYF"></span>[letters:x]</span>
                For this frame only, the text box will show the next x characters.
            </p>
           
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[instant:allowcommand]</span>
                The same as <span class="term">[instant]</span>, but here other text commands are launched, except <span class="term">[w]</span>, <span class="term">[letters]</span> and commands with the "<span class="term">skipover</span>" tag.
            </p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[instant:stop]</span>
                Stops a previously launched <span class="term">[instant:allowcommand]</span>.
            </p>

            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[instant:stopall]</span>
                Stops a previously launched <span class="term">[instant:allowcommand]</span> or a player skip.
            </p>
           
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[name]</span>
                This text gets replaced by by the name of the player. I totally forgot that we could actually use <span class="term">Player.name</span>, but 
				whatever.
            </p>
           
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[music:x]</span>
                Plays the music given as an argument on the main music channel, unless the argument is one of these keywords:
                <ul>
                    <li><span class="term">play</span> = Only plays the last played music, from the beginning.</li><br>
                    <li><span class="term">pause</span> = Pauses the music.</li><br>
                    <li><span class="term">unpause</span> = Unpauses the music.</li><br>
                    <li><span class="term">stop</span>, <span class="term">null</span>, <span class="term">nil</span> or an empty string = Stops the current 
					music.</li><br>
                </ul>
            </p>
           
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[sound:x]</span>
                Plays the sound given as an argument.
            </p>
           
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[mugshot:x]</span>
                Changes the current text mugshot for overworld texts with mugshots only.
            </p>
           
            <p class="exblock">
                <br><span class="function"><span class="CYF"></span>[health:x,y]</span>
                Heals the Player by x points. Can damage the player if x is negative, but the Player's HP
                will not go under 1 unless certain conditions are met. The parameter y is optional.
                <br><br>
                Examples:
                <ul>
                    <li><span class="term">[health:3]</span> => Heals 3 HP.</li><br>
                    <li><span class="term">[health:-5]</span> => Damages 5 HP. Doesn't go under 1HP.</li><br>
                </ul>
                Tags:
                <ul>
                    <li>x (y is unused if these tags are used):
                        <ul>
                            <li><span class="term">kill</span> = Kills the Player.</li><br>
                            <li><span class="term">Max-1</span> = Sets the Player's HP at Player's Max HP minus 1.</li><br>
                            <li><span class="term">Max</span> = Sets the Player's HP at Player's Max HP.</li><br>
                        </ul>
                    </li>
                    <li>y:
                        <ul>
                            <li><span class="term">killable</span> = The possible HP reduction can now kill the Player.</li><br>
                            <li><span class="term">set</span> = The amount of HP given in the first argument will be the Player's current HP.</li><br>
                        </ul>
                    </li>
                </ul>
            </p>
           
            <h3>Command tags</h3><br><br>
           
            <p><span class="CYF"></span><br>These tags can be added after a text command and have different behaviours.<br>
            To use them, you must do this: <span class="term">[command:tag]</span> or <span class="term">[command:arguments:tag]</span>. For now, only one 
			tag can be added at a time.</p>
           
            <p class="exblock">
                <br><span class="function">skipover</span>
                Makes a command only be activated when the text is not skipped (by using any <span class="term">[instant]</span> command or the 
				player's skip if <span class="term">playerskipdocommand</span> is set to true). Has no effect on <span class="term">[w]</span> and
				<span class="term">[letters]</span>.
            </p>
           
            <p class="exblock">
                <br><span class="function">skiponly</span>
                The command will only be launched if the text has been skipped by using any <span class="term">[instant]</span> command or the player's skip if
                <span class="term">playerskipdocommand</span> is set to true. This tag disables <span class="term">[w]</span> and <span class="term">[letters]
				</span> commands if used on them.
            </p>
        </div>

        <div class="tab-pane text-style" id="api-events">
            <h2>Game events</h2><br><br>
            <p>This section is all about game events. Game events are functions in your scripts that the Unitale engine
                runs at various points in the game. By changing up your behaviour depending on the actions the player
                takes, you can go beyond a basic encounter and make it great.</p>
            <p>There are two kinds of events. We'll refer to them as <i>inherited events</i> and <i>script-specific
                events</i>. An <i>inherited event</i> is a function that gets run first on your Encounter script. If the
                function is not found in the Encounter script, it will try to run the same function on all monsters. If
                it's not found there either, it will resort to a default, built-in handler. <i>Script-specific
                    events</i> are, as the name implies, functions that only happen for this specific script type. We'll
                start with the first type.</p>
            <hr>
            <h3>Inherited events (Encounter -> Monster)</h3><br><br>
            <p>
                <br><span class="function">EncounterStarting()</span>
                Happens once when everything's done initializing but before any encounter actions start. You should do
                things like stopping the music here, or using <span class="term">State()</span> if you want to start the fight off with some
                dialogue.
            </p>
            <p>
                <br><span class="function">EnemyDialogueStarting()</span>
                Happens when you go to the monster dialogue state. You're still free to modify monster dialogue here.
            </p>
            <p>
                <br><span class="function">EnemyDialogueEnding()</span>
                Happens when you go from the monster dialogue state to the defending state.
            </p>
            <p>
                <br><span class="function">DefenseEnding()</span>
                Happens when you go from the defending state of the game to any other state. If you read up on the
                <span class="term">RandomEncounterText()</span> function, you'll want to use it here.
            </p>
            <div class="code-container">
  <pre class="brush:lua;">
function HandleItem(ItemID)
	if ItemID == "DOGTEST2" then
		BattleDialog({"You selected The Second Dog.", "You are truly great."})
	else
		BattleDialog({"You didn't select The Second Dog.", "You could've picked better."})
	end
end
</pre>
            </div>
            <p>
                <br><span class="function">HandleSpare()</span>
                Happens when you select the Spare option from the Mercy menu, regardless of whether a monster is
                spareable or not. This event fires <i>after</i> the sparing of monsters is completed. If you spare the
                last enemy in the encounter, this function will not happen - the encounter is over at that point.
            </p>

            <h3>Script-specific events</h3><br><br>
            <h4>Encounter script events</h4>
            <p>
                <br><span class="function">HandleItem(item_ID)</span>
                Happens when you select an item from the item menu. <br>
				<span class="CYF"></span> In CYF, you can use the Inventory object to edit the player's inventory.
				The items' names will be in caps, like with <span class="term">HandleCustomCommand()</span>.
            </p>
            <p>
                <br><span class="function">EnteringState(newstate, oldstate)</span>
                A new, more flexible way of handling state changes. When you enter a new state, this function will fire
                with <i>newstate</i> containing the new state's name, and <i>oldstate</i> containing the previous
                state's name. Both are in all caps. One of the most powerful things about it is that you can use <span class="term">State()</span>
                here to interrupt state changes initiated by the engine itself.
                <br>
                <br>Possible states and when they execute are below:
            </p>
            <ul>
                <li><span class="term">ACTIONSELECT</span> - Returning to the main part of the battle, where you can select
                    FIGHT/ACT/ITEM/MERCY.
                </li><br>
                <li><span class="term">ATTACKING</span> - When you've selected a target with the FIGHT option.</li><br>
                <li><span class="term">DEFENDING</span> - When the enemy/enemies finish dialogue, and one or more waves start.</li><br>
                <li><span class="term">ENEMYSELECT</span> - When you've selected either FIGHT or ACT, and need to select an enemy.</li><br>
                <li><span class="term">ACTMENU</span> - When you've selected an ACT target, and must now select an ACT command.</li><br>
                <li><span class="term">ITEMMENU</span> - When you've selected ITEM.</li><br>
                <li><span class="term">MERCYMENU</span> - When you've selected MERCY.</li><br>
                <li><span class="term">ENEMYDIALOGUE</span> - When your enemy/enemies start their dialogue.</li><br>
                <li><span class="term">DIALOGRESULT</span> - When you call <span class="term">BattleDialog()</span>, or when the UI shows text on its own 
				(e.g. when using an item).
                </li><br>
            </ul>
			Note: There are three states not mentioned here - because they never occur naturally. You can find them in <span class="ref">Functions &amp; 
			objects</span>.
            <br><br>For a clearer example, here's a code snippet replicating the older events above.
            <div class="code-container">
  <pre class="brush:lua;">
function EnteringState(newstate, oldstate)
	if newstate == "ENEMYDIALOGUE" then
		--same as EnemyDialogueStarting()
	elseif newstate!= "ENEMYDIALOGUE" and oldstate == "ENEMYDIALOGUE" then
		--same as EnemyDialogueEnding(). Alternatively, check for newstate == "DEFENDING"
	elseif newstate!= "DEFENDING" and oldstate == "DEFENDING" then
		--same as DefenseEnding()
	end
end
</pre>
            </div>
            <p>
                <br><span class="function">Update()</span>
                This function runs for every frame for all of the encounter, even during waves. For advanced users: the
                Update function is required to exist at the beginning of the encounter. If you define it at a later
                point in time, it will not get executed.
            </p>

            <h4>Monster script events</h4>
            <p>
                <br><span class="function">HandleAttack(damage)</span>
                Happens the moment the player's attack has applied damage - this is when you hear the hitting sound
                after the slash animation. <span class="term">damage</span> will be -1 if the player pressed Fight, but didn't press any
                buttons and let it end by itself. The monster's <span class="term">hp</span> variable will have updated at this time, too.
                Don't call <span class="term">BattleDialog()</span> here, it's a bit buggy right now.
            </p>
            <p>
                <br><span class="function">OnDeath()</span>
                Happens after your attack's shaking animation has completed and the monster's HP is 0. If you implement
                <span class="term">OnDeath()</span>, your monster will not die automatically, and you will have to do it manually with the Kill()
                function. OnDeath() will only happen through monster kills that happened with the FIGHT command;
                scripted <span class="term">Kill()</span> calls will not trigger it. Calling <span class="term">BattleDialog()</span> here will probably 
				screw up the battle UI.
            </p>
            <p>
                <br><span class="function"><span class="CYF"></span>OnSpare()</span>
                Happens after you successfully spared a monster. If you implement <span class="term">OnSpare()</span>, your monster will not be
				spared automatically, and you will have to do it manually with the <span class="term">Spare()</span> function. <span class="term">OnSpare()
				</span> will only happen through a monster spare that happened with the SPARE command - scripted <span class="term">Spare()</span> calls will 
				not trigger it.
            </p>
			<p>
                <br><span class="function"><span class="CYF"></span>BeforeDamageCalculation()</span>
                Happens before the damage calculation after pressing Z when attacking. You can easily use <span class="term">SetDamage()</span>
				in this function and lots of other animations and such.
				<br><i>Previous name: <span class="term">OnAttack()</span></i>
            </p>
			<p>
                <br><span class="function"><span class="CYF"></span>BeforeDamageValues()</span>
                Happens before the damage ui is displayed on the monster (the life bar and the damage number) and before
				the hp changing. You can still change the target with <span class="term">Player.changeTarget(targetNumber)</span> in this function.
            </p>
            <p>
                <br><span class="function">HandleCustomCommand(actcommand)</span>
                Happens when you select an Act command on this monster. <span class="term">actcommand</span> will be the same as how you
                defined it in the <span class="term">commands</span> list, except it will be <i>in all caps</i>. Intermediate example
                below, showing how you can use it and spice it up a little.
            </p>
            <div class="code-container">
  <pre class="brush:lua;">
commands = {"Sing", "Dance", "Wiggle"} --somewhere at the beginning
wigglecounter = 0 --let's keep a counter to check how often we've wiggled
 
function HandleCustomCommand(command)
	if command == "SING" then
		BattleDialog({"You sing your heart out. It's in the arena now."})
	elseif command == "DANCE" then
		BattleDialog({"You busted out your best moves."})
	elseif command == "WIGGLE" then
		if wigglecounter == 0 then --you can use variables to make commands more exciting!
			BattleDialog({"You just kind of stood there and wiggled."})
		elseif wigglecounter == 1 then
			BattleDialog({"You're still kind of standing there and wiggling."})
		else
			BattleDialog({"Your wiggled so often that your wiggling technique\ris now legendary."})
		end
		wigglecounter = wigglecounter + 1 --be sure to increase the wiggle counter, or it'll stay at 0
	end
end
</pre>
            </div>
            <h4>Wave script events</h4>
            <p>
                <br><span class="function">Update()</span>
                This function is launched every frame (usually at 60FPS) while monsters are attacking (the defense step). That's pretty
                much it. Update your bullets here - more on bullet creation and control is on the <span class="ref">API - Projectile
                management</span> page.
            </p>
            <p>
                <br><span class="function"><span class="CYF"></span>EndingWave()</span>
                This function is launched just before the wave ends. It permits you to easily reset some variables and other such things.
            </p>
            <p>
                <br><span class="function">OnHit(bullet)</span>
                Every time a bullet collides with a player, this function gets called on the script that created the
                projectile. The bullet object in this function can be modified if you feel like it. For more information
                on the bullet object, see the documentation above.<br>
                <br>
                If you implement this function in your script, you have to define manually what should happen after
                bullet collision. This is what allows you to create orange, cyan and green projectiles, and much much
                more. If you don't implement this function in your wave script, it'll stick to the default of dealing 3
                damage on hit.<!-- Below are multiple examples of how to use this function. -->
            </p>
        </div>

        <div class="tab-pane text-style" id="api-functions-main">
            <h2>Functions &amp; Objects</h2><br><br>
            <p>
                This section details functions Unitale adds to your Lua scripts to interact with the game in various
                ways. All functions will have a suffix in square brackets to denote in which scripts they may be used.
                The key for this is E for Encounter, M for Monster and W for Wave. If, for example, a function can be
                used in all scripts, it will be written as <i>functionName() [E/M/W]</i>.
            </p>
			
			<p>
                <br><span class="function"><span class="CYF"></span> isCYF [E/M/W]</span>
				A value - true by default - that indicates that if you're on CYF. nil if not on CYF. Test it with
				<span class="term">if not isCYF then</span> or <span class="term">if isCYF then</span>.
            </p>
			
			<p>
                <br><span class="function"><span class="CYF"></span> safe [E/M/W]</span>
				True if CYF's safe mode is enabled, false otherwise.
            </p>
			
			<p>
                <br><span class="function"><span class="CYF"></span> windows [E/M/W]</span>
				Returns true if the user is on Windows, false otherwise.
            </p>
			
			<p>
                <br><span class="function"><span class="CYF"></span> CYFversion [E/M/W]</span>
				Returns the current version of CYF. For example: for CYF 0.4.5, it'll return "0.4.5".
            </p>

            <p>
                <br><span class="function">DEBUG(text) [E/M/W]</span>
                Write text to the debug console (toggleable with <span class="term">F9</span>). It will appear automatically the first time you
                write text to it. You can use this to check values in your code, or make sure some pieces of code are
                actually running.
            </p>

            <p>
                <br><span class="function">SetGlobal(your_variable_name, value) [E/M/W]</span>
				DEPRECATED. Instead, set variables in the Encounter script, as it is accessible from everywhere.
                <br>You can retrieve these variables with <span class="term">Encounter.GetVar("yourvar")</span> or <span class="term">Encounter["yourvar"]
				</span> and set them with <span class="term">Encounter.SetVar("yourvar", value)</span> or <span class="term">Encounter["yourvar"] = value.</span> 
				(For more info, scroll down and look for <span class="term">The Script object (and the Encounter object)</span>)<br>
                Sets a global variable. After setting, you can retrieve it from all your scripts at any time with
                <span class="term">GetGlobal(variable_name)</span>.
            </p>

            <p>
                <br><span class="function">GetGlobal(your_variable_name) returns variable [E/M/W]</span>
				DEPRECATED. Instead, set variables in the Encounter script, as it is accessible from everywhere.
                <br>Gets a Global Variable that you previously set using <span class="term">SetGlobal()</span>.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> SetRealGlobal(your_variable_name, value) [E/M/W]</span>
                Sets a Global variable that is accessible even in the overworld. After setting it, you can retrieve it from all of
				your scripts at any time with <span class="term">GetRealGlobal(variable_name)</span>.
				Persists through battles, but not between sessions. These variables can be saved using the overworld save system.<br>
                Can be used on the overworld.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> GetRealGlobal(your_variable_name) returns variable [E/M/W]</span>
                Gets a Global that you previously set using <span class="term">SetRealGlobal()</span>.<br>
                Can be used on the overworld.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> SetAlMightyGlobal(your_variable_name, value) [E/M/W]</span>
                <i>AlMighty Globals</i> are globals that are instantly saved into a file when set: these globals persists
				through sessions, even in devMod mode, and can't be removed.
				However, you can still access the "Remove AlMighty Globals" button in devMod to remove them.<br>
                Can be used on the overworld.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> GetAlMightyGlobal(your_variable_name) returns variable [E/M/W]</span>
                Gets an AlMighty Global that you previously set using <span class="term">SetAlMightyGlobal()</span>.<br>
                Can be used on the overworld.
            </p>
			
			<p>
                <br><span class="function"><span class="CYF"></span> SetFrameBasedMovement(bool) [E/M/W]</span>
				Set to "true" if you want a frame-based player movement (2px/frame) instead of a time based player movement (120px/s).
				Set it to "false" if you already are in a frame-based movement and you want to go back to a time based movement.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> SetAction("FIGHT" or "ACT") [E/M/W]</span>
                Used alongside <span class="term">EnteringState</span> to force the player to go on FIGHT or ACT. Does nothing outside of this function.
            </p>
           
            <p>         
                <br><span class="function"><span class="CYF"></span> AllowPlayerDef(bool) [E/M/W]</span>
                If this value is set to true, all damage that the player will take will be reduced - like in Undertale - by 1 point for each 5 defense,
                with the player's defense at LV1 not affecting the damage.<br/>
                Each damage that is originally positive but lower than 1 will be replaced by 1.
				<br>False by default.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> SetPPCollision(bool) [E/M/W]</span>
                Setting this to true will force all bullets that don't have a specified collision type to use the Pixel-Perfect collision system.
				If you want to use it, then I'd highly recommend seeing <span class="ref">The Pixel-Perfect Collision System</span>.
				<br>False by default.
            </p>

            <p>
                <br><span class="function">BattleDialog(list_of_strings) [E/M/W]</span>
                This makes the list of strings you give to the function appear in the UI dialog box. After skipping through
                them, you will automatically go to the monster dialogue step by default. Below is a working example of
                how you could use it for a Vegetoid encounter.
            </p>
            <div class="code-container">
   <pre class="brush: lua;">
function HandleCustomCommand(command)
	if command == "DINNER" then
		if ate_greens then -- ate_greens is a non-default variable, of course
			currentdialogue = {"Ate\nYour\nGreens"}
		else
			currentdialogue = {"Eat\nYour\nGreens"}
		end
		BattleDialog({"You pat your stomach.\nVegetoid offers a healthy meal."})
	end
end
</pre>
                <p>(For the Lua specialists; it is indeed a table of strings rather than a list of strings.)</p>
            </div>

            <p>
                <br><span class="function">State(state_to_go_to) [E/M/W]</span>
                A powerful function that immediately skips the battle to the specified state, rather than following the
                default conventions. Below is a list of valid strings you can pass to it, what state you'll be going to
                and what that state entails. The states you pass to it are case-invariant, but uppercase is recommended
                for readability.
            </p>
            
			<p>            
                Arguably the best part about <span class="term">State</span> is that it can be used in conjunction with the text command <span class="term">
                [func]</span> to change the state from within your dialogue. An example is below - this will have a monster say that he will
                not fight you, then return to the action select screen rather than launching an attack.
            </p>
            
            <div class="code-container">
                <pre class="brush: lua;">currentdialogue = {"I won't fight you.", "[func:State,ACTIONSELECT]"}</pre>
            </div>
            
            <ul>
                <li><span class="term">ACTIONSELECT</span> - While in this state, you can select FIGHT/ACT/ITEM/MERCY.</li><br>
                <li><span class="term">ENEMYDIALOGUE</span> - When starting this state, <span class="term">currentdialogue</span> gets read from the 
					Encounter script for every monster and their dialogue is displayed. If that doesn't exist, it'll return something at
                    random from the <span class="term">randomdialogue</span> list.
                </li><br>
                <li><span class="term">DEFENDING</span> - When starting this state, <span class="term">nextwaves</span> is read out from the Encounter 
					script and all scripts in the Waves folder with matching names will be part of this defense step. <span class="term">wavetimer</span>
                    is also read from the Encounter script at this time.
                </li><br>
			</ul>
            
			<p>
                There are some other states available, but entering some might have nasty side effects. It's possible that
                they might lock up your battle if you enter them with <span class="term">State</span>. So, use at your own risk:
            </p>
            
			<ul>
				<li><span class="term">ATTACKING</span> - Starting this state will put you in the screen where you either deal damage to an enemy by pressing
				"Z" at the right time, or you wait and miss entirely. The enemy this affects is the same as the last enemy selected in the states <span class=
				"term">ENEMYSELECT</span> or <span class="term">ACTMENU</span>. After this state ends, the encounter moves on to the <span class="term">
				ENEMYDIALOGUE</span> state by default.</li><br>
				<li><span class="term">ENEMYSELECT</span> - This state displays a list of all active enemies in the encounter. This state gets entered
				automatically after choosing FIGHT or ACT. If the Player got here from choosing FIGHT, the state loaded from pressing "Z" is <span class=
				"term">ATTACKING</span>, if they got here from choosing ACT, that state will be <span class="term">ACTMENU</span>, but if they got here from
				calling <span class="term">State</span> and press "Z", nothing will happen.</li><br>
				<li><span class="term">ACTMENU</span> - This state displays all of the options from the enemy's <span class="term">commands</span> in order. 
				If the enemy has <span class="term">cancheck</span> set to <i>true</i>, then a "Check" option will be displayed here - which
				will follow the syntax seen in the description for <span class="term">commands</span> as seen in <span class="ref">Basic Setup</span>. 
				Having more than 6 ACT commands may cause glitchiness, though, so watch out! (Additional note: the enemy chosen will always be the same as
				the last enemy chosen in <span class="term">ENEMYSELECT</span>.)</li><br>
				<li><span class="term">ITEMMENU</span> - This state shows all of the player's available items. It's tied with the
				<span class="term">HandleItem</span> function (see <span class="ref">Game events</span> for more information).</li><br>
				<li><span class="term">MERCYMENU</span> - This state lets you choose from either "Spare" or "Flee". If at least one active enemy
				has <span class="term">canspare</span> set to <i>true</i>, then "Spare" will be yellow - and selecting it will spare that enemy.
				Otherwise, if the option is not yellow, then choosing "Spare" will activate the encounter function <span class="term">HandleSpare</span>.
				Also, choosing "Flee" prompts some (not necessarily) hilarious messages.<br><span class="CYF"></span> If the encounter was entered from the
				overworld, choosing "Flee" allows the player to flee the battle and return to the overworld.</li><br>
				<li><span class="term">DIALOGRESULT</span> - This is the state that is entered whenever <span class="term">BattleDialog</span> is called,
				when the victory message displays, when the player fails to flee, or when an item is used. When all text is done and the player presses 
				"Z", the state <span class="term">ENEMYDIALOGUE</span> is entered next. Also, note that the soul is invisible during this
				state, so anything you could do to change its sprite won't be visible until afterwards.</li><br>
            </ul>
            
			<p>
                Finally, there are three states that are <i>never</i> entered during regular gameplay. These include:
			</p>
            
			<ul>
				<li><span class="term">DONE</span> - The most functional of the three non-regular states. Currently, this immediately returns you to the mod 
				selection screen.</li><br>
				<li><span class="term">NONE</span> - A mostly-deprecated state. Technically, this <i>is</i> entered in regular gameplay - but only once:
				in the very first frame of the encounter. When entered manually, it freezes the entire battle. If called in
				<span class="term">EncounterStarting</span>, the soul will appear at the bottom-left corner of the screen. During this state,
				absolutely nothing occurs. No regular inputs do anything, enemies' dialogues don't advance, bullets don't move - nothing.</li><br>
				<li><span style="color:#ffffff;border-bottom:1px solid #ffffff;"><0.2.1a></span> <span class="term">RESETTING</span> - This state
				is 100% deprecated. It's something lvkuln left behind in Unitale v0.2.1a, but removed in the open-source (github) release. 
				Previous testing shows that this state will only "exist" for a single frame when entered, before the player is returned to their
				previous state, just before the encounter freezes up. However, if it's called on every single frame during the state.</li><br>
			</ul>
            
			<p>
                <br><span class="function"><span class="CYF"></span> GetCurrentState() [E/M/W]</span>
				Returns the name of the current state (see above for all states).
            </p>
            
            <p>
                <br><span class="function">SetSprite(filename) [M]</span>
                Sets the monster's sprite from the Sprites folder to <span class="term">filename.png</span>. Can be used with <span class="term">[func]
				</span> to change sprites mid-dialogue.
            </p>

            <p>
                <br><span class="function">SetActive(active) [M]</span>
                Either true or false. If false, this monster will stay on screen but will not show up in menus, do its
                dialogue or run any of its events. You can use this to introduce monsters to an encounter at a later
                point. The battle will end when a monster is killed or spared and there are no active monsters left.
                Having no active monsters at all will likely cause a bunch of errors right now.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> SetDamage(amount) [M]</span>
                Set the next attack's amount of damage. Can be negative.<br>
				<b>YOU HAVE TO USE IT IN A FUNCTION!</b> You also don't want to use it beside <span class="term">SetActive(false)</span>.
            </p>

            <p>
                <br><span class="function">Kill() [M]</span>
                Kills the monster immediately. If this was the last monster, the battle ends.
            </p>

            <p>
                <br><span class="function">Spare() [M]</span>
                Spares the monster immediately. Similar to <span class="term">Kill()</span>, if this was the last monster, the battle ends.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> Move(float x, float y, bool bindToArena = false) [M]</span>
                Moves the enemy's sprite from its current position.<br>
				<span class="term">bindToArena</span>: if the enemy's sprite will follow the Arena. Same as <span class="term">BindToArena()</span>.
            </p>
			
			<p>
				<br><span class="function"><span class="CYF"></span> MoveTo(float x, float y, bool bindToArena = false) [M]</span>
				Moves the enemy's sprite relative to the bottom left corner.
				<span class="term">bindToArena</span>: if the enemy's sprite will follow the Arena. Same as <span class="term">BindToArena()</span>.
			</p>
			
			<p>
			    <br><span class="function"><span class="CYF"></span> BindToArena(bool bind, bool isUnderArena = false) [M]</span>
				Controls whether the enemy's sprite will follow the Arena's movements.
                <span class="term">isUnderArena</span>: will the enemy's sprite be under the arena?
			</p>
			
			<p>
			    <br><span class="function"><span class="CYF"></span> SetBubbleOffset(int x, int y) [M]</span>
				Makes the enemy's dialogue bubble appear, relative to its original position: <span class="term">x</span> pixels horizontally and
				<span class="term">y</span> pixels vertically.
			</p>
			
			<p>
			    <br><span class="function"><span class="CYF"></span> SetDamageUIOffset(int x, int y) [M]</span>
				Changes the offset of the enemy's damage UI (the enemy's health bar and the red numbers). Note that the damage UI is on a layer
				above that of the arena.
			</p>
			
			<p>
			    <br><span class="function"><span class="CYF"></span> SetSliceAnimOffset(int x, int y)[M]</span>
				Changes the offset of the attack animation (the red slice by default) for when the player attacks this monster.
			</p>

            <p>
                <br><span class="function">RandomEncounterText() returns string [E]</span>
                Select a random monster from the encounter, then get a random entry from the <span class="term">comments</span> table there.
                You'll want to use this to replicate default encounter behaviour. See code below (or one of the example
                encounters).
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> SetButtonLayer(string layer) [E]</span>
                Changes the <span class="term">layer</span> of the FIGHT, ACT, ITEM and MERCY buttons.
                The usable layers are created sprite layers and those base layers:
				<ul>
				    <li><span class="term">"Bottom"</span>: Under everything, even the background.</li><br>
				    <li><span class="term">"BelowUI"</span>: Above the background.</li><br>
				    <li><span class="term">"BelowArena"</span>: Above the background and the UI.</li><br>
				    <li><span class="term">"BelowPlayer"</span>: Above the background, the UI and the Arena.</li><br>
				    <li><span class="term">"BelowBullet"</span>: Above the background, the UI, the Arena and the Player.</li><br>
				    <li><span class="term">"Top"</span>: Above everything.</li><br>
				    <li><span class="term">"default"</span>: Will put the buttons where they usually are in the sprite hierarchy.</li><br>
				</ul>
            </p>
            <div class="code-container">
   <pre class="brush: lua;">function DefenseEnding() --This built-in function fires after the defense round ends.
	encountertext = RandomEncounterText()
end</pre>
            </div>
        </div>

        <div class="tab-pane text-style" id="api-functions-player">
            <p>
                <br><span class="function">The Player object [E/M/W]</span>
                You can use this object to obtain information about the player. Since the player is always 16x16 pixels
                in Undertale, you can add/subtract 8 from the player's horizontal/vertical position to get the edges of
                the player's hitbox, if you need that for anything.
            </p>
            <ul>
				<li><span class="term">Player.x</span> (readonly) - gets the X position of the <i>player's center</i> relative to the arena's
                    center.
                </li><br>
                <li><span class="term">Player.y</span> (readonly) - get the Y position of the <i>player's center</i> relative to the arena's
                    center.
                </li><br>
                <li><span class="term">Player.absx</span> (readonly) - get the X position of the <i>player's center</i> relative to the bottom
                    left corner of the screen.
                </li><br>
                <li><span class="term">Player.absy</span> (readonly) - get the Y position of the <i>player's center</i> relative to the bottom
                    left corner of the screen.
                </li><br>
                <li><span class="term">Player.sprite</span> - the Player's soul sprite component. See the <span class="ref">Sprites &amp; Animation</span> 
					section for usage details.
                </li><br>
                <li><span class="term">Player.hp</span> - get or set the player's current HP. Can't exceed max HP. If set to 0, game over
                    triggers.<br>
					<span class="CYF"></span> * The hp value is now a float, but there can be some problems about accuracy of float values.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.maxhp</span> (readonly) - returns the player's MaxHP value. <br> 
					* The hp value is now a float, but there can be some problems about accuracy of float values.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.maxhpshift</span> (readonly) - returns the difference between the player's current Max HP and their normal, 
				unmodified Max HP.
				<br>* The hp value is now a float, but there can be some problems about accuracy of float values.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.atk</span> (readonly) - base attack of the player. Depends on the player's level.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.weapon</span> (readonly) - name of the player's current weapon.
                </li><br>
				<li><span class="CYF"></span> <span class="term">Player.weaponatk</span> (readonly) - attack value of the player's current weapon.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.def</span> (readonly) - base defense of the player. Depends on the player's level.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.armor</span> (readonly) - name of the player's current armor.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.armordef</span> (readonly) - defense value of the player's current armor.
                </li><br>
				<li><span class="term">Player.name</span> - get or set the player's current name. <br>
				    <span class="CYF"></span> 9 letters max. "Rhenao" by default.</li><br>
                <li><span class="term">Player.lv</span> - use this to get or set the player's current level. It can be between 1 and 20. It's 1 by default. 
				<span class="CYF"></span> 99 max - Player starts with 20HP / 10 ATK and gets 4 HP / 2 ATK per level. Leveling up the player through code 
				doesn't automatically heal them; you'll have to do this manually.
                </li><br>
				<li><span class="CYF"></span> <span class="term">Player.lastenemychosen</span> (readonly) - gets the id of the last chosen enemy in the 
				ACT/FIGHT menus. -1 at the beginning of a fight.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.lasthitmultiplier</span> (readonly) - gets the accuracy value from the last time the
				player was in <span class="term">ATTACKING</span>. Normally, it will be between 0 and 2. It will be -1 if the player missed the attack (and 
				at the beginning of the battle) and 2.2 if the attack was perfectly precise.
                </li><br>
                <li><span class="term">Player.ishurting</span> (readonly) - true if the player's currently blinking due to being hurt, false
                    otherwise.
                </li><br>
                <li><span class="term">Player.ismoving</span> (readonly) - true if the player is currently moving in battle, false otherwise. Will
                    always be false while not in a wave script. NOTE: This only will change with the default control scheme (see below).
                </li><br>
                <li><span class="term">Player.Hurt(damage)</span> - deals damage to the player, and makes them invincible for the default time.
                </li><br>
                <li><span class="term">Player.Hurt(damage, invul_time)</span> - deals damage to the player, and makes them invincible for <span class="term">
				invul_time</span> seconds.
                </li><br>
                <li><span class="term">Player.Heal(value)</span> - heals the player for this amount. This is exactly the same as
                    Player.Hurt(-value, 0). It also plays the healing sound.
                </li><br>
                <li><span class="term">Player.SetControlOverride(boolean)</span> - either true or false. Only useable in waves. If true, this will
                    prevent the player soul from doing its regular movement/keyboard control for the rest of the wave.
                    Use this if you want to implement your own controls in a wave.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.Move(x, y, ignoreWalls)</span> - Moves the player soul based on its last position.
					If <span class="term">ignoreWalls</span> is false, it will make sure the player doesn't go outside of the arena;
                    otherwise, it ignores the arena's boundaries. If you want to move the player out of bounds in a wave, you'll
                    have to call <span class="term">Player.SetControlOverride(true)</span>, as the player's default movement keeps the soul inside
                    the arena otherwise.
                </li><br>
				<li><span class="term">Player.MoveTo(x, y, ignoreWalls)</span> - Moves the player soul to this position relative to the arena's
                    center. If <span class="term">ignoreWalls</span> is false, it will make sure the player doesn't go outside of the arena;
                    otherwise, it ignores the arena's boundaries. If you want to move the player out of bounds in a wave, you'll
                    have to call <span class="term">Player.SetControlOverride(true)</span> as the player's default movement keeps the soul inside
                    the arena.
                </li><br>
                <li><span class="term">Player.MoveToAbs(x, y, ignoreWalls)</span> - Moves the player soul to this position relative to the bottom left
                    of the screen. If <span class="term">ignoreWalls</span> is false, it will make sure the player doesn't go outside of the arena;
                    otherwise, it ignores the arena's boundaries. If you want to move the player out of bounds in a wave, you'll
                    have to call <span class="term">Player.SetControlOverride(true)</span> as the player's default movement keeps the soul inside
                    the arena.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.ForceHP(int amount)</span> - Lets you set the player's HP to a number above the 
				player's Max HP. The REAL maximum is 1.5 times the player's MaxHP.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Player.SetMaxHPShift(int shift, float invulnerabilitySeconds = 1.7f, bool set = false,
				bool canHeal = false)</span> - Lets you set the Player's MaxHP, relative to their normal MaxHP. If the total MaxHP is negative or nil, it
					causes a GameOver.<br>
					Formula: Player's MaxHP = Basis MaxHP + MaxHP Shift
					<ul>
						<li><span class="term">shift</span> = The value that will be added to the Max HP. If <span class="term">set</span> is true,
						this will be the player's <i>new</i> Max HP.</li><br>
						<li><span class="term">invulnerabilitySeconds</span> = The time for which the player will be invulnerable after this operation.
						</li><br>
						<li><span class="term">set</span> = true if you want to set the Player's MaxHP directly.</li><br>
						<li><span class="term">canHeal</span> = true if the player will be able to heal up to this new Max HP value.</li><br>
					</ul>
                </li><br>
	            <li><span class="CYF"></span> <span class="term">Player.SetAttackAnim(table anim, float frequency)</span> - Sets the animation used
				when attacking an enemy. Use it like <span class="term">sprite.SetAnimation()</span></li><br>
				<li><span class="CYF"></span> <span class="term">Player.ResetAttackAnim()</span> - Resets the animation of the player's 
				attack to the default slashing animation.</li><br>
                <li><span class="CYF"></span> <span class="term">Player.ChangeTarget(int targetNumber)</span> - Changes the target of the Player's attack
				while in <span class="term">ATTACKING</span>. Does nothing outside of the state <span class="term">ATTACKING</span>.
					It should be used in <span class="term">BeforeDamageCalculation()</span> or <span class="term">BeforeDamageValues()</span>.</li><br>
				<li><span class="CYF"></span> <span class="term">Player.ForceAttack(int enemyID, int damage = normal_damage_values)</span> - Forces an 
					attack towards the enemy number <span class="term">enemyID</span>. If you want to, you can choose the attack's damage, too - but 
					otherwise, damage will be calculated normally.
					<br><span style="color:#aa0000">After using this function, you have to check with <span class="term">Player.CheckDeath</span> to really 
					kill enemies that lost all their health this way.</span></li><br>
				<li><span class="CYF"></span> <span class="term">Player.MultiTarget(table targetIDs = all, table damage = normal_damage_values)</span> - The 
					next attack the player executes will attack the enemies contained in <span class="term">targetIDs</span> and deal <span class="term">
					damage</span> damage. If you want to, you can choose the attack's damage, too - but otherwise, damage will be calculated normally.
					If you put nothing as a parameter, this will attack all enemies with the normal damage calculations.</li><br>
				<li><span class="CYF"></span> <span class="term">Player.MultiTarget(int damage)</span> - The next attack the player executes will attack all 
				enemies and deals <span class="term">damage</span> damage.</li><br>
				<li><span class="CYF"></span> <span class="term">Player.ForceMultiAttack(table targetIDs = all, table damage = normal_damage_values)</span> 
					- Forces an attack towards the enemies contained in <span class="term">targetIDs</span> and deals <span class="term">damage
					</span> damage. If you want to, you can choose the attack's damage, too - but otherwise, damage will be calculated normally.
					If you put nothing as a parameter, this will attack all enemies with the normal damage calculations.
					<br><span style="color:#aa0000">After using this function, you have to check with <span class="term">Player.CheckDeath</span> to really 
					kill enemies that lost all their health this way.</span></li><br>
				<li><span class="CYF"></span> <span class="term">Player.ForceMultiAttack(int damage)</span> - Forces an attack that deals 
				<span class="term">damage</span> damage to all enemies.
					<br><span style="color:#aa0000">After using this function, you have to check with <span class="term">Player.CheckDeath</span> to really 
					kill enemies that lost all their health this way.</span></li><br>
				<li><span class="CYF"></span> <span class="term">Player.CheckDeath()</span> - Checks if the enemies are dead after a forced attack.
					I don't kill the enemies from forced attacks because death texts will be easier to implement if you use
					<span class="term">ForceAttack</span> or <span class="term">ForceMultiAttack</span> in the middle of text.</li><br>
			</ul>
        </div>

        <div class="tab-pane text-style" id="api-functions-script">
            <p>
                <br><span class="function">The Script object (and the Encounter object) [varies]</span>
                Script objects are a bit of a special case. They're used to refer to other scripts that were loaded by
                the engine itself. In the encounter script, the <i>enemies</i> table is filled with Script objects after
                the encounter starts and the <i>Wave</i> table is filled with Script object in the state <span class="term">DEFENDING</span>. The Encounter 
				object is also a script object that refers to the current encounter, and is accessible from anywhere except from the Encounter itself. Take 
				note of the different way of accessing variables.
            </p>
            <ul>
                <li><span class="term">script.GetVar("variable_name")</span> - gets <span class="term">variable_name</span> from the script.</li><br>
                <li><span class="term">script["variable_name"]</span> - same as the above.</li><br>
                <li><span class="term">script.SetVar("variable_name", value)</span> - sets <span class="term">variable_name</span> on the script.</li><br>
                <li><span class="term">script["variable_name"]</span> = value - same as the above.</li><br>
                <li><span class="term">script.Call("function_name")</span> - runs <span class="term">function_name</span> from within the script.</li><br>
            </ul>

            <p>So for instance, you can do <span class="term">enemies[1].Call("Kill")</span> to kill the first monster from your encounter. You
                can do <span class="term">Encounter.SetVar("wavetimer", 1.0)</span> from anywhere to change the wave timer to 1 second.
            </p>       
        </div>

        <div class="tab-pane text-style" id="api-functions-audio">
            <p>
                <br><span class="function">The Audio object [E/M/W]</span>
                The Audio object allows you to control music in the game and play sounds. Here are the ways in which you
                can use it.
            </p>
            <ul>
                <li><span class="term">Audio.playtime</span> - Get the current play position of the current music in seconds.</li><br>
                <li><span class="term">Audio.totaltime</span> - Get the total length of the current music in seconds.</li><br>
                <li><span class="term">Audio.isplaying</span> - Returns true if the music is playing, or false if the music is stopped or paused.</li><br>
				
                <li><span class="term">Audio.Play()</span> - Play the currently loaded music. Done automatically at the beginning of a fight.</li><br>
                <li><span class="term">Audio.Stop()</span> - Stops the music. If you want a battle not to have music, call this in 
				<span class="term">EncounterStarting()</span>.
                </li><br>
                <li><span class="term">Audio.Pause()</span> - Pause the music.</li><br>
                <li><span class="term">Audio.Unpause()</span> - Unpause the music if you previously paused it.</li><br>
                <li><span class="term">Audio.Volume(value)</span> - Set music to given volume. <span class="term">value</span> should be between
				0.0 (muted) and 1.0 (full volume). This is 0.75 by default.
                </li><br>
                <li><span class="term">Audio.Pitch(value)</span> - Set music pitch to given value. 1.0 is default, 2.0 is twice the regular speed.
                    Negative values play the music backwards. <span class="term">value</span> should be between -3.0 and 3.0.
                </li><br>
                <li><span class="term">Audio.LoadFile(filename)</span> - Load music from the Audio folder titled <span class="term">filename.ogg</span>
				or <span class="term">filename.wav</span> and play it immediately. If you don't want immediate playback,
				call <span class="term">Audio.Stop()</span> after this.
                </li><br>
                <li><span class="term">Audio.PlaySound(filename)</span> - Play the sound from the Sounds folder titled
				<span class="term">filename.ogg</span> or <span class="term">filename.wav</span>.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Audio.StopAll()</span> - Stops all playing audio.</li><br>
                <li><span class="CYF"></span> <span class="term">Audio.PauseAll()</span> - Pauses all the audio sources.</li><br>
                <li><span class="CYF"></span> <span class="term">Audio.UnpauseAll()</span> - Unpauses all the audio sources.</li><br>
                <li><span class="CYF"></span> <span class="term">Audio.GetSoundDictionary(key)</span> - Returns the index of the sound in the
                    sound dictionary. Returns the key itself if the key isn't in the dictionary.</li><br>
                <li><span class="CYF"></span> <span class="term">Audio.SetSoundDictionary(key, value)</span> - Adds a sound to the sound dictionary. Doing 
				so permits you to change the name of the sounds played by the engine - like, for example, <span class="term">hurtsound</span>
				or <span class="term">menumove</span>.</li><br>
                <li><span class="CYF"></span> <span class="term">Audio[key]</span> - Fast way to use <span class="term">Audio.SetSoundDictionary</span>
				/<span class="term">GetSoundDictionary</span>.</li><br>
            </ul>

            <p>As it's an object, you can't directly use it with <span class="term">[func]</span>, but you can make your own function if you want
                to, say, stop the music mid-dialogue:</p>
            <div class="code-container">
   <pre class="brush: lua;">currentdialogue = {"but then I realized...\n[w:30][func:drama]the butler did it!!!"}
  
function drama()
	Audio.Stop()
	Audio.PlaySound(dramatic_sound_effect)
end</pre>
            </div>
        </div>

        <div class="tab-pane text-style" id="api-functions-newaudio">
			<p>
                <br><span class="function"><span class="CYF"></span> The NewAudio object [E/M/W]</span>
                The NewAudio object allows you to create sound channels and has an overall better music management than the Audio object.
            </p>
            <ul>
			    <li><span class="term">NewAudio.CreateChannel(name)</span> - Creates the audio channel <span class="term">name</span>.</li><br>
			    <li><span class="term">NewAudio.DestroyChannel(name)</span> - Destroys the audio channel <span class="term">name</span>.</li><br>
			    <li><span class="term">NewAudio.Exists(name)</span> - Checks if the audio channel <span class="term">name</span> exists.</li><br>
			    <li><span class="term">NewAudio.GetAudioName(name)</span> - Gets the name of the audio channel <span class="term">name</span>.</li><br>
                <li><span class="term">NewAudio.GetTotalTime(name)</span> - Get the total time of the last clip played on the channel 
				<span class="term">name</span>.</li><br>
				<li><span class="term">NewAudio.GetCurrentTime(name)</span> - Get the current play position of the current audio of this channel
				in seconds.</li><br>
			    <li><span class="term">NewAudio.PlayMusic(name, music, loop = false, volume = 1)</span> - Plays the music <span class="term">music</span> on 
				the channel <span class="term">name</span>. <span class="term">loop</span> tells the engine if it has to loop the music or not; 
				<span class="term">volume</span> is the volume of the music.</li><br>
			    <li><span class="term">NewAudio.PlaySound(name, music, loop = false, volume = 0.65)</span> - Plays the sound <span class="term">sound</span> 
				on the channel <span class="term">name</span>. <span class="term">loop</span> tells the engine if it has to loop the sound or not; 
				<span class="term">volume</span> is the volume of the sound. The base volume of sounds and voices are both 0.65.</li><br>
			    <li><span class="term">NewAudio.PlayVoice(name, music, loop = false, volume = 0.65)</span> - Plays the voice <span class="term">voice</span> 
				on the channel <span class="term">name</span>. <span class="term">loop</span> tells the engine if it has to loop the voice or not; 
				<span class="term">volume</span> is the volume of the voice. The base volume of sounds and voices are both 0.65.</li><br>
			    <li><span class="term">NewAudio.SetPitch(name, value)</span> - Sets the pitch of the audio channel <span class="term">name</span>.</li><br>
			    <li><span class="term">NewAudio.GetPitch(name)</span> - Gets the pitch of the audio channel <span class="term">name</span></li><br>
			    <li><span class="term">NewAudio.SetVolume(name, value)</span> - Sets the volume of the audio channel <span class="term">name</span></li><br>
			    <li><span class="term">NewAudio.GetVolume(name)</span> - Gets the volume of the audio channel <span class="term">name</span></li><br>
				<li><span class="term">NewAudio.Play(name)</span> - Plays the last sound played in the audio channel <span class="term">name</span></li><br>
				<li><span class="term">NewAudio.Stop(name)</span> - Stops the audio channel <span class="term">name</span>.</li><br>
				<li><span class="term">NewAudio.Pause(name)</span> - Pauses the audio channel <span class="term">name</span>.</li><br>
				<li><span class="term">NewAudio.Unpause(name)</span> - Unpauses the audio channel <span class="term">name</span>.</li><br>
				<li><span class="term">NewAudio.SetPlayTime(name, value)</span> - Sets the track position of the music in the audio channel
				<span class="term">name</span>, in seconds.</li><br>
				<li><span class="term">NewAudio.GetPlayTime(name)</span> - Gets the track position of the audio channel <span class="term">name</span>, 
				in seconds.</li><br>
				<li><span class="term">NewAudio.StopAll()</span> - Stops all the audio channels.</li><br>
				<li><span class="term">NewAudio.PauseAll()</span> - Pauses all the audio channels.</li><br>
				<li><span class="term">NewAudio.UnpauseAll()</span> - Unpauses all the audio channels.</li><br>
				<li><span class="term">NewAudio.IsStopped(name)</span> - Checks if the audio channel <span class="term">name</span> is stopped.</li><br>
            </ul>
        </div>

        <div class="tab-pane text-style" id="api-functions-input">
            <p>
                <br><span class="function">The Input object [E/M/W]</span>
                The Input object allows you to retrieve input status. All keys will return a number; 0 when not pressed,
                1 on the first frame the key is pressed, 2 while it's being held, and -1 while it's released. You can
                check if a key's value is greater than 0 to see if it's pressed, or if it's exactly 1/-1 to only have an
                action if it was just pressed/released. Possible key options are below.<br>
                <br>
                Note: do not rely on the Input object to replace proper UI controls. Changing game state in the UI based
                on input will likely cause a fair share of issues and is not supported at this moment (but feel free to
                see what does and doesn't work).
            </p>
            <ul>
                <li><span class="term">Input.Confirm</span> - Z or Enter keys</li><br>
                <li><span class="term">Input.Cancel</span> - X or Left Shift keys</li><br>
                <li><span class="term">Input.Menu</span> - C or Left Control keys</li><br>
                <li><span class="term">Input.Up</span> - Up arrow or <span class="CYF"></span> W</li><br>
                <li><span class="term">Input.Down</span> - Down arrow or <span class="CYF"></span> S</li><br>
                <li><span class="term">Input.Left</span> - Left arrow or <span class="CYF"></span> A</li><br>
                <li><span class="term">Input.Right</span> - Right arrow or <span class="CYF"></span> D</li><br>
                <li><span class="CYF"></span> <span class="term">Input.GetKey(string keyname)</span> - Get the state of the given key.
				<br>Check the <span class="ref">Key List</span> to see the available keys.</li><br>
                <li><span class="CYF"></span> <span class="term">Input.MousePosX</span> (readonly) - Returns the X position of the mouse relative to the 
				bottom left corner of the screen. (from 0 to 640)</li><br>
                <li><span class="CYF"></span> <span class="term">Input.MousePosY</span> (readonly) - Returns the Y position of the mouse relative to the 
				bottom left corner of the screen. (from 0 to 480)</li><br>
                <li><span class="CYF"></span> <span class="term">Input.IsMouseInWindow</span> (readonly) - Returns true if the mouse is in the window, false 
				otherwise.</li><br>
            </ul>
        </div>

        <div class="tab-pane text-style" id="api-functions-time">
            <p>
                <br><span class="function">The Time object [E/M/W]</span>
                The Time object serves as a way to retrieve game timing without having to keep track of it yourself, or
                using a frame counter. Whenever possible, try using the Time object over a frame-based timing method to
                ensure equal behaviour across all framerates.
            </p>
            <ul>
                <li><span class="term">Time.time</span> - Time (in seconds) since the game application started. If you want to time specific
                    events, store <span class="term">Time.time</span> in a variable of your own at the start of what you want to time, then
                    subtract <span class="term">Time.time</span> from your stored time to calculate the difference.
                </li><br>
                <li><span class="term">Time.dt</span> - Delta time (in seconds). This is the time it took for the last game update to complete.
                </li><br>
                <li><span class="term">Time.mult</span> - Multiplier to ensure equal movement across all framerates (this is essentially
                    deltatime*framerate). This will be around 1.0 when the application runs at 60FPS, ~0.5 at 120FPS and
                    ~2.0 at 30FPS, etc. By multiplying your movement by this value, your waves will be consistent on
                    lower framerates as well.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Time.wave</span> - Returns the remaining time before the end of the waves in
				<span class="term">DEFENDING</span>. -1 outside of <span class="term">DEFENDING</span>.</li><br>
            </ul>
        </div>

        <div class="tab-pane text-style" id="api-functions-misc">
			<p>
                <br><span class="function"><span class="CYF"></span> The Misc object [E/M/W]</span>
                The Misc object has some window-related and computer-related functions. Most of them are functions:
				don't forget to check if the user is playing with a Windows OS by using the variable <span class="term">windows</span>!
            </p>
            <ul>
                <li><span class="term">Misc.MachineName</span> (read-only) - Returns the name of the player's session.</li><br>
                <li><span class="term">Misc.ShakeScreen(int durationInFrames, int intensity = 3, bool isIntensityDecreasing = false)</span> - Shakes the 
                screen for <span class="term">durationInFrames</span> frames, with a maximum of <span class="term">intensity</span> pixels out of the 
                normal position. Set <span class="term">isIntensityDecreasing</span> as true to reduce the intensity over time.</li><br>
                <li><span class="term">Misc.StopShake()</span> - Stops a previously launched <span class="term">Misc.ShakeScreen</span>, does nothing 
                otherwise.</li><br>
                <li><span class="term">Misc.FullScreen</span> - Fullscreen mode.</li><br>
                <li><span class="term">Misc.ScreenWidth</span> - Returns the width of the user's screen.</li><br>
                <li><span class="term">Misc.ScreenHeight</span> - Returns the height of the user's screen.</li><br>
                <li><span class="term">Misc.DestroyWindow()</span> - Closes the window instantly.</li><br>
                <span style="color:#aa0000;font-size:18px;">THE FOLLOWING VARIABLES AND FUNCTIONS ARE <u>WINDOWS ONLY</u>.</span><br><br>
                <li><span class="term">Misc.WindowName</span> - Gets or sets the name of the window.</li><br>
                <li><span class="term">Misc.WindowX</span> - Gets or sets the X position of the bottom left corner of the window.</li><br>
                <li><span class="term">Misc.WindowY</span> - Gets or sets the Y position of the bottom left corner of the window.</li><br>
                <li><span class="term">Misc.MoveWindow(int X, int Y)</span> - Move the window by X pixels horizontally and Y pixels vertically.</li><br>
                <li><span class="term">Misc.MoveWindowTo(int X, int Y)</span> - Moves the bottom left corner of the window to the given coordinates.
                </li><br>
                <li><span class="term">Misc.WindowWidth</span> (readonly) - The width of the window.</li><br>
                <li><span class="term">Misc.WindowHeight</span> (readonly) - The height of the window.</li>
            </ul>
        </div>

        <div class="tab-pane text-style" id="api-functions-waves">
            <h3>Wave scripts</h3><br><br>
            
            <p>The following section is dedicated exclusively to wave scripts. We'll go over special functions and the
                arena object. As you can now create projectiles from the encounter as well, information about
                projectiles and their examples have been moved to the <span class="ref">API - Projectile management</span> section.
             </p>
             
            <p>
                <br><span class="function">The Arena object [W]</span>
                You can use this object to obtain information about the arena, resize it or move it.<br>
				Don't forget that the Arena's position is reset at the end of the wave!
            </p>
            
            <ul>
                <li><span class="term">Arena.width</span> (readonly) - the width of the arena in pixels, after resizing. Since the reference for
                    the player and bullets is the arena's center, you can get the left/right side of the arena with
                    <span class="term">-Arena.width/2</span> and <span class="term">Arena.width/2</span> respectively.
                </li><br>
                <li><span class="term">Arena.height</span> (readonly) - the height of the arena in pixels, after resizing. Like with width, you
                    can get the bottom/top with <span class="term">-Arena.height/2</span> and <span class="term">Arena.height/2</span> respectively.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Arena.x</span> (readonly) - the x position of the center of the Arena, after resizing.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Arena.y</span> (readonly) - the position of the bottom of the Arena, after resizing. To get 
				that of the center, just do <span class="term">Arena.y + Arena.height/2</span>.
                </li><br>
                <li><span class="term">Arena.currentwidth</span> (readonly) - the <i>current</i> width of the arena in pixels. Differs from
					<span class="term">width</span> in that it will accurately reflect the arena size in the middle of resizing, too.
                </li><br>
                <li><span class="term">Arena.currentheight</span> (readonly) - the <i>current</i> height of the arena in pixels. Differs from
					<span class="term">height</span> in that it will accurately reflect the arena size in the middle of resizing, too.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.currentx</span> (readonly) - the <i>current</i> x of the arena in pixels. Differs 
					from <span class="term">x</span> in that it will accurately reflect the arena position in the middle of moving, too.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.currenty</span> (readonly) - the <i>current</i> y of the arena in pixels. Differs 
					from <span class="term">y</span> in that it will accurately reflect the arena position in the middle of moving, too.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.isresizing</span> (readonly) - Tells you if the Arena is currently being resized.
				<br><span style="color:#ffffff;text-decoration:underline;text-decoration-color:#ffffff">&lt;0.2.1a&gt;</span>: There's an equivalent of this in 
				0.2.1a - just use <span class="term">Arena.currentwidth != Arena.width and Arena.currentheight != Arena.height</span>.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.ismoving</span> (readonly) - Tells you if the Arena is currently being moved.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.ismodifying</span> (readonly) - Returns true if the Arena is being moved <i>or</i> 
				resized, false otherwise.</li><br>
				<li><span class="term">Arena.Resize(width, height)</span> - Resizes the arena to the new size. Currently, monsters stay on top of
                    the arena. This was going to be changed around the animation update.<br><span class="CYF"></span> But, in CYF, you can use
					<span class="term">BindToArena</span> to control that!
                </li><br>
                <li><span class="term">Arena.ResizeImmediate(width, height)</span> - Resizes the arena instantly, without the animation.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.Move(x, y, bool movePlayer = true, bool immediate = false)</span> - Moves the Arena 
					based on its current position. Set <span class="term">movePlayer</span> to true if you want the Player to move with the Arena and set
					<span class="term">immediate</span> to true if you want to move the Arena immediately.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.MoveTo(x, y, bool movePlayer = true, bool immediate = false)</span> - Moves the Arena 
					based on the bottom-left corner of the window. Set <span class="term">movePlayer</span> to true if you want the Player to move with the 
					Arena and set <span class="term">immediate</span> to true if you want to move the Arena immediately.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.MoveAndResize(x, y, width, height, bool movePlayer = true, bool immediate = false)
				</span> - Moves the Arena based on its current position and resizes it at the same time.<br>
				    Set <span class="term">movePlayer</span> to true if you want the Player to move with the Arena and set <span class="term">immediate
					</span> to true if you want to move the Arena immediately.</li><br>
                <li><span class="CYF"></span> <span class="term">Arena.MoveToAndResize(x, y, width, height, bool movePlayer = true, bool immediate = false)
				</span> - Move the Arena based on the bottom-left corner of the window and resizes it at the same time.<br>
				    Set <span class="term">movePlayer</span> to true if you want the Player to move with the Arena and set <span class="term">immediate
					</span> to true if you want to move the Arena immediately.</li><br>
			</ul>

            <p>
                <br><span class="function">EndWave() [W]</span>
                Ends this wave immediately. You can only call this function from the Update function.
            </p>

            <p>
                <br><span class="function"><span class="CYF"></span> wavename [W]</span>
                Returns the name of the wave file, without extension, from the Waves folder.
            </p>
        </div>

        <div class="tab-pane text-style" id="api-keys" style="color:#ffffff">
		    <h2><span class="CYF"></span> Key List</h2><br><br>
			
			<p>
			<h4>Regular Alphabet:</h4>
			(All regular alphabet characters are exactly the same between their key names and CYF Key IDs.<br>For instance, the <span class="term">A</span> 
			key will be <span class="term">A</span> in CYF.)
			</p>
			
			<br><p>
			<h4>F-keys:</h4>
			(All F-keys are exactly the same between their key names and CYF Key IDs.<br>For instance, the <span class="term">F12</span> 
			key will be <span class="term">F12</span> in CYF.<br>For reference, the supported F-keys are <span class="term">F1</span> through
			<span class="term">F15</span>.)
			</p>
			
			<br><p>
			<h4>Keyboard Number Keys:</h4>
			<table class="keys">
				<tr>
					<th>Keyboard Key</th>
					<th>ID for CYF use</th>
				</tr>
				<tr>
					<td>1</td>
					<td>Alpha1</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Alpha2</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Alpha3</td>
				</tr>
				<tr>
					<td>4</td>
					<td>Alpha4</td>
				</tr>
				<tr>
					<td>5</td>
					<td>Alpha5</td>
				</tr>
				<tr>
					<td>6</td>
					<td>Alpha6</td>
				</tr>
				<tr>
					<td>7</td>
					<td>Alpha7</td>
				</tr>
				<tr>
					<td>8</td>
					<td>Alpha8</td>
				</tr>
				<tr>
					<td>9</td>
					<td>Alpha9</td>
				</tr>
				<tr>
					<td>0</td>
					<td>Alpha0</td>
				</tr>
			</table>
			</p>
			
			<br><p>
			<h4>Keypad Keys:</h4>
			<table class="keys">
				<tr>
					<th>Keyboard Key</th>
					<th>ID for CYF use</th>
				</tr>
				<tr>
					<td>1 (End)</td>
					<td>Keypad1</td>
				</tr>
				<tr>
					<td>2 (Down)</td>
					<td>Keypad2</td>
				</tr>
				<tr>
					<td>3 (Page Down)</td>
					<td>Keypad3</td>
				</tr>
				<tr>
					<td>4 (Left)</td>
					<td>Keypad4</td>
				</tr>
				<tr>
					<td>5</td>
					<td>Keypad5</td>
				</tr>
				<tr>
					<td>6 (Right)</td>
					<td>Keypad6</td>
				</tr>
				<tr>
					<td>7 (Home)</td>
					<td>Keypad7</td>
				</tr>
				<tr>
					<td>8 (Up)</td>
					<td>Keypad8</td>
				</tr>
				<tr>
					<td>9 (Page Up)</td>
					<td>Keypad9</td>
				</tr>
				<tr>
					<td>0 (Insert)</td>
					<td>Keypad0</td>
				</tr>
				<tr>
					<td>. (Del)</td>
					<td>KeypadPeriod</td>
				</tr>
				<tr>
					<td>/</td>
					<td>KeypadDivide</td>
				</tr>
				<tr>
					<td>*</td>
					<td>KeypadMultiply</td>
				</tr>
				<tr>
					<td>-</td>
					<td>KeypadMinus</td>
				</tr>
				<tr>
					<td>+</td>
					<td>KeypadPlus</td>
				</tr>
				<tr>
					<td>Enter</td>
					<td>KeypadEnter</td>
				</tr>
				<tr>
					<td>=</td>
					<td>KeypadEquals</td>
				</tr>
			</table>
			</p>
			
			<br><p>
			<h4>Keyboard Number Keys:</h4>
			<table class="keys">
				<tr>
					<th>Keyboard Key</th>
					<th>ID for CYF use</th>
				</tr>
				<tr>
					<td>↑</td>
					<td>UpArrow</td>
				</tr>
				<tr>
					<td>↓</td>
					<td>DownArrow</td>
				</tr>
				<tr>
					<td>→</td>
					<td>RightArrow</td>
				</tr>
				<tr>
					<td>←</td>
					<td>LeftArrow</td>
				</tr>
			</table>
			</p>
			
			<br><p>
			<h4>Special Keyboard Keys:</h4>
			<i>Note: the</i> <span class="term">%</span> <i>key cannot be detected as of this moment.</i><br><br>
			<table class="keys">
				<tr>
					<th>Keyboard Key</th>
					<th>ID for CYF use</th>
				</tr>
				<tr>
					<td>Backspace</td>
					<td>Backspace</td>
				</tr>
				<tr>
					<td>Tab</td>
					<td>Tab</td>
				</tr>
				<tr>
					<td>Return/Enter</td>
					<td>Return</td>
				</tr>
				<tr>
					<td>Pause</td>
					<td>Pause</td>
				</tr>
				<tr>
					<td>Space Bar</td>
					<td>Space</td>
				</tr>
				<tr>
					<td>Escape</td>
					<td>Escape</td>
				</tr>
				<tr>
					<td>!</td>
					<td>Exclaim</td>
				</tr>
				<tr>
					<td>@</td>
					<td>At</td>
				</tr>
				<tr>
					<td>#</td>
					<td>Hash</td>
				</tr>
				<tr>
					<td>$</td>
					<td>Dollar</td>
				</tr>
				<tr>
					<td>^</td>
					<td>Caret</td>
				</tr>
				<tr>
					<td>&amp;</td>
					<td>Ampersand</td>
				</tr>
				<tr>
					<td>*</td>
					<td>Asterisk</td>
				</tr>
				<tr>
					<td>(</td>
					<td>LeftParen</td>
				</tr>
				<tr>
					<td>)</td>
					<td>RightParen</td>
				</tr>
				<tr>
					<td>-</td>
					<td>Minus</td>
				</tr>
				<tr>
					<td>+</td>
					<td>Plus</td>
				</tr>
				<tr>
					<td>_</td>
					<td>Underscore</td>
				</tr>
				<tr>
					<td>=</td>
					<td>Equals</td>
				</tr>
				<tr>
					<td>:</td>
					<td>Colon</td>
				</tr>
				<tr>
					<td>;</td>
					<td>Semicolon</td>
				</tr>
				<tr>
					<td>"</td>
					<td>DoubleQuote</td>
				</tr>
				<tr>
					<td>'</td>
					<td>Quote</td>
				</tr>
				<tr>
					<td>,</td>
					<td>Comma</td>
				</tr>
				<tr>
					<td>.</td>
					<td>Period</td>
				</tr>
				<tr>
					<td>\</td>
					<td>Backslash</td>
				</tr>
				<tr>
					<td>/</td>
					<td>Slash</td>
				</tr>
				<tr>
					<td>?</td>
					<td>Question</td>
				</tr>
				<tr>
					<td>&lt;</td>
					<td>Less</td>
				</tr>
				<tr>
					<td>&gt;</td>
					<td>Greater</td>
				</tr>
				<tr>
					<td>[</td>
					<td>LeftBracket</td>
				</tr>
				<tr>
					<td>]</td>
					<td>RightBracket</td>
				</tr>
				<tr>
					<td>`</td>
					<td>BackQuote</td>
				</tr>
			</table>
			</p>
			
			<br><p>
			<h4>Misc. Keyboard Keys:</h4>
			<table class="keys">
				<tr>
					<th>Keyboard Key</th>
					<th>ID for CYF use</th>
				</tr>
				<tr>
					<td>Insert</td>
					<td>Insert</td>
				</tr>
				<tr>
					<td>Home</td>
					<td>Home</td>
				</tr>
				<tr>
					<td>Delete</td>
					<td>Delete</td>
				</tr>
				<tr>
					<td>End</td>
					<td>End</td>
				</tr>
				<tr>
					<td>Page Up</td>
					<td>PageUp</td>
				</tr>
				<tr>
					<td>Page Down</td>
					<td>PageDown</td>
				</tr>
				<tr>
					<td>Num Lock</td>
					<td>NumLock</td>
				</tr>
				<tr>
					<td>Caps Lock</td>
					<td>CapsLock</td>
				</tr>
				<tr>
					<td>Scroll Lock</td>
					<td>ScrollLock</td>
				</tr>
				<tr>
					<td>Right Shift</td>
					<td>RightShift</td>
				</tr>
				<tr>
					<td>Left Shift</td>
					<td>LeftShift</td>
				</tr>
				<tr>
					<td>Right Control</td>
					<td>RightControl</td>
				</tr>
				<tr>
					<td>Left Control</td>
					<td>LeftControl</td>
				</tr>
				<tr>
					<td>Right Alt</td>
					<td>RightAlt</td>
				</tr>
				<tr>
					<td>Left Alt</td>
					<td>LeftAlt</td>
				</tr>
				<tr>
					<td>Right Command</td>
					<td>RightCommand</td>
				</tr>
				<tr>
					<td>Left Command</td>
					<td>LeftCommand</td>
				</tr>
				<tr>
					<td>Right Apple Key</td>
					<td>RightApple</td>
				</tr>
				<tr>
					<td>Left Apple Key</td>
					<td>LeftApple</td>
				</tr>
				<tr>
					<td>Right Windows Key</td>
					<td>RightWindows</td>
				</tr>
				<tr>
					<td>Left Windows Key</td>
					<td>LeftWindows</td>
				</tr>
				<tr>
					<td>Alt Gr</td>
					<td>AltGr</td>
				</tr>
				<tr>
					<td>Print Screen/Sys Rq</td>
					<td>SysReq</td>
				</tr>
				<tr>
					<td>Break</td>
					<td>Break</td>
				</tr>
				<tr>
					<td>Menu</td>
					<td>Menu</td>
				</tr>
			</table>
			</p>
			
			<br><p>
			<h4>Mouse Inputs:</h4>
			<table class="keys">
				<tr>
					<th>Mouse Input</th>
					<th>ID for CYF use</th>
				</tr>
				<tr>
					<td>Left Mouse Button</td>
					<td>Mouse0</td>
				</tr>
				<tr>
					<td>Right Mouse Button</td>
					<td>Mouse1</td>
				</tr>
				<tr>
					<td>Scroll Wheel Down</td>
					<td>Mouse2</td>
				</tr>
				<tr>
					<td>Mouse 3</td>
					<td>Mouse3</td>
				</tr>
				<tr>
					<td>Mouse 4</td>
					<td>Mouse4</td>
				</tr>
				<tr>
					<td>Mouse 5</td>
					<td>Mouse5</td>
				</tr>
				<tr>
					<td>Mouse 6</td>
					<td>Mouse6</td>
				</tr>
			</table>
			</p>
        </div>

        <div class="tab-pane text-style" id="cyf-inventory">
            <h2><span class="CYF"></span> Create Your Frisk: The Inventory System</h2><br><br>
            <p>
                It was hard to customize items and such in Unitale, right? Plus, items wouldn't go away when you used them,
                because they are the only ones that will ever love you. But now, nobody loves you at all, items
                can be deleted and the Inventory System has been simplified! Here are the functions that are created to
                help you with this hellish mechanism that added items.
				<br><br>Some of these functions can only be used in <span class="term">HandleItem</span>. Examples are 
				included at the bottom of this page.
                <br><br>Don't forget to use inventory functions like this: <span class="term">Inventory.function</span>!
            </p><br>
			
            <p>
                <br><span class="function">Inventory.GetItem(int index)</span>
                Returns the name of the item of the inventory at the given index.
                <br><span class="term" style="margin-left:20px">index</span> = Index of the chosen item.
            </p>
            <p>
                <br><span class="function">Inventory.SetItem(int index, string Name)</span>
				Sets the inventory item at <span class="term">index</span> to the item <span class="term">Name</span>.
                <br><span class="term" style="margin-left:20px">index</span> = Index to put the item in. The first item is position 1.
                <br><span class="term" style="margin-left:20px">Name</span> = Name of the item to put in the inventory.
            </p>
            <p>
                <br><span class="function">Inventory.AddCustomItems(table names, table types)</span>
                If you want to add custom items, this has to be used before <span class="term">SetInventory</span>.
				This adds all items in <span class="term">names</span> to the inventory, where each item matches to an 
				item type in <span class="term">types</span>. If you don't do this, the engine
                will not recognise your newly created items.
				<br><br>Usage: <span class="term">Inventory.AddCustomItems({"item1", "item2"}, {1, 0})</span>
				<br><br><span class="term" style="margin-left:20px">names</span> = The names of your custom items.
				<br><span class="term" style="margin-left:20px">types</span> = The item types of your custom items. This array must be same size as <span class="term">names</span>.

				<br>Types:<br>
			    <div style="margin-left:20px">
				    <span class="term">0</span> = Consumable. Will be deleted upon use.
				    <br><span class="term">1</span> = Weapon. You will be able to equip this item as a weapon.
				    <br><span class="term">2</span> = Armor. You will be able to equip this item as armor.
				    <br><span class="term">3</span> = Special. This item will not be deleted upon use.
				</div>
            </p>
            <p>
                <br><span class="function">Inventory.SetInventory(table names)</span>
                Sets the player's inventory. To use custom items, this must be used after <span class="term">AddCustomItems</span>.
                <br>This function is used like this: <span class="term">Inventory.SetInventory({"item1", "item2"})</span>;
                <br><span class="term" style="margin-left:20px">names</span> = The names of the items.
            </p>
            <p>
                <br><span class="function">Inventory.ItemCount</span>
                Returns the number of items the player has in their inventory. Read-only.
            </p>
            <p>
                <br><span class="function">Inventory.NoDelete</span>
				<i>In the encounter function</i> <span class="term">HandleItem</span>, using this with <span class="term">Inventory.NoDelete</span> as true will make the item the player is using stay in the inventory.
            </p>
            <p>
                <br><span class="function">Inventory.SetAmount(int amount)</span>
				Used with Weapon and Armor items. If the item is a Weapon, this sets its ATK. If the item is armor,
				this sets its DEF.
                <br><span class="term" style="margin-left:20px">amount</span>: the amount of ATK/DEF the item will have.
            </p>
			<br><br><h4>Examples:</h4>
			<br>Example of a healing item:
			<br><div class="code-container"><pre class="brush: lua">
function EncounterStarting()
	Inventory.AddCustomItems({"Starfait"}, {0})
	Inventory.SetInventory({"Starfait"})
end

function HandleItem(ItemID)
	if ItemID == "STARFAIT" then
		Player.Heal(14)
		BattleDialog({"You eat the Starfait.[w:10]\nYou recovered 14 HP!"})
	end
end
			</pre></div>
			<br>Example of a weapon:
			<br><div class="code-container"><pre class="brush: lua">
function EncounterStarting()
	Inventory.AddCustomItems({"Shotgun"}, {1})
	Inventory.SetInventory({"Shotgun"})
end

function HandleItem(ItemID)
	if ItemID == "SHOTGUN" then
		Inventory.SetAmount(16777215)
		BattleDialog({"You equipped the Shotgun."})
	end
end
			</pre></div>
			<br>Example of armor:
			<br><div class="code-container"><pre class="brush: lua">
function EncounterStarting()
	Inventory.AddCustomItems({"Shield"}, {2})
	Inventory.SetInventory({"Shield"})
end

function HandleItem(ItemID)
	if ItemID == "Shield" then
		Inventory.SetAmount(8)
		BattleDialog({"You equipped the rusty shield."})
	end
end
			</pre></div>
			<br>Example of a special item:
			<br><div class="code-container"><pre class="brush: lua">
function EncounterStarting()
	Inventory.AddCustomItems({"Music Box"}, {3})
	Inventory.SetInventory({"Music Box"})
end

function HandleItem(ItemID)
	if ItemID == "MUSIC BOX" then
		BattleDialog({"[noskip]You wind up the music box.[w:10]\nA haunting melody fills the room.", "The enemy's DEF drops!"})
		enemies[1].SetVar("def", enemies[1].GetVar("def") / 2)
	end
end
			</pre></div>
			<br>Example of a persistent item:
			<br><div class="code-container"><pre class="brush: lua">
function EncounterStarting()
	Inventory.AddCustomItems({"Test"}, {0})
	Inventory.SetInventory({"Test"})
end

function HandleItem(ItemID)
	if ItemID == "TEST" then
		Inventory.NoDelete = true
		BattleDialog({"This item won't be\rdeleted!"})
	end
end
			</pre></div>
			<br>Many items:
			<br><div class="code-container"><pre class="brush: lua">
function EncounterStarting()
	Inventory.AddCustomItems({"Test", "Test2", "Shotgun", "Shield", "PsnPotion", "Life Roll", "Nothing"}, {0, 0, 1, 2, 0, 0, 3})
	Inventory.SetInventory({"Test", "Test2", "Shotgun", "Shield", "PsnPotion", "Life Roll", "Nothing"})
end

function HandleItem(ItemID)
    if (ItemID == "TEST") then
        Inventory.NoDelete = true
        BattleDialog({"This is a persistent item.[w:5]\nThe item will be in the\rinventory in the next turn!"})
    elseif (ItemID == "TEST2") then
        BattleDialog({"This is a normal item.[w:10]\nThe item will be gone\rby the next turn!"})
    elseif (ItemID == "SHOTGUN") then
        Inventory.SetAmount(16777215)
		BattleDialog({"You equipped the Shotgun."})
	elseif (ItemID == "SHIELD") then
		Inventory.SetAmount(30)
		AllowPlayerDef(true)
		BattleDialog({"You equipped the shield."})
    elseif (ItemID == "PSNPOTION") then
        BattleDialog({"You drank the Poison Potion.","[noskip][waitall:10]...[waitall:1][w:20]\rThat was a bad idea.[w:20][health:kill]"})
    elseif (ItemID == "LIFE ROLL") then
        BattleDialog({"Your HP goes to 1[waitall:10]...[waitall:1][health:1,set]now.[w:20]\nNow, byebye![w:20][health:-1, killable]"})
    elseif (ItemID == "NOTHING") then
        BattleDialog({"You use Nothing. [w:10]Did you really\rthink that something would\rhappen?"})
    end
end
			</pre></div>
        </div>
		
        <div class="tab-pane text-style" id="cyf-ppcollision">
			<h2><span class="CYF"></span> Create Your Frisk: The Pixel-Perfect Collision System</h2><br><br>
				<p>Have you had enough of Unitale's default rectangular collisions and having to use thousands of lines
				of <span class="term">if</span> statements in <span class="term">OnHit</span> just to get precise
				collisions? Then the Pixel-Perfect Collision System is for YOU!</p>
				<p>You can use this system for your entire encounter with <span class="term">SetPPCollision(bool)</span>,
				or you can apply it just to a bullet with <span class="term">bullet.ppcollision</span>. 
				The bullet's <span class="term">ppcollision</span> value will override the encounter's
				<span class="term">ppcollision</span> value.</p>
				<p>But wait just a minute before rushing to use the Pixel-Perfect Collision System...or not, do as you want!</p>
				<p>Now, the Pixel-Perfect Collision System also supports bullets with scale! You can rotate and move bullets
				like always and collision will still work! (this is why it took me one week to make this feature)</p>
				<p>Anoter thing: the Pixel-Perfect Collision System is more resource-intensive than the Normal Collision
				System. So, I'll warn you: only use this for bullets that <i>need</i> Pixel-Perfect Collision; don't use it
				for <i>all</i> bullets.</p>
				<p>One last tip: Don't use Pixel-Perfect for bullets that won't damage you, as that will just waste resources!</p>
			<p>
				<br><span class="function">Bullet.ppcollision</span>
				The collision system of the bullet. If true, this bullet will use Pixel-Perfect Collision.
			</p>
			<p>
				<br><span class="function">SetPPCollision(bool) [E/M/W]</span>
				Setting this to true will force all bullets that don't have a specified collision type to be Pixel-Perfect bullets.
				<br>False by default.
			</p>
			<br><br><br>
			<img src="img/PP.png">
        </div>
		
        <div class="tab-pane text-style" id="cyf-text">
			<h2><span class="CYF"></span> Create Your Frisk: The Text Object</h2><br><br>
			<p>A lot of people were waiting for this: I'm proud to present you the Text Object! With it, you can create text
				wherever you want, with a bubble or without a bubble, with a speech thing or without a speech thing... It's 100%
				your choice!</p>
			<p>Plus, if you choose to make a bubble, the height of the bubble is automatically computed, but you can still choose the
				bubble's height if you want to.</p>
            <p>By default, a Text Object has a bubble with an automatically-set height, with no speech thing. Plus, the object is hidden when
				you enter or come out of <span class="term">ENEMYDIALOGUE</span>. If you want to change this, there are a lot of functions
				to do so. Look down to see them!
			</p>
			<p>
				<br><span class="function">CreateText(Table text, Table position, int textWidth, string layer = "BelowPlayer", int bubbleHeight = -1) returns TextObject [E/M/W]</span>
				This function creates a Text Object and returns it. However, as you can see, a lot of parameters are needed, here is what you should put:
				<ul>
				    <li><span class="term">text</span> - The text to display. Used the same way as in <span class="term">BattleDialog</span>: 
					<span class="term">{"Text 1", "Text 2"}</span></li><br>
				    <li><span class="term">position</span> - The position of the center of the object. Sorry if it may be hard to place it, but you'll be 
					able to use <span class="term">SetPivot</span> to place it better afterwards. You only need two numbers, like this: 
					<span class="term">{320, 240}</span></li><br>
				    <li><span class="term">textWidth</span> - You'll always need the text's width! The bubble's width will be 20px larger than the text's 
					width. Also, bubbles have a minimum width of 40.<br>Example: <span class="term">150</span></li><br>
				    <li><span class="term">layer</span> - The sprite layer of the Text Object. If it doesn't exist, it returns an error. This argument is 
					optional. If it's not provided, the Text Object will be in the layer <span class="term">BelowPlayer</span> if you don't set this value. 
					<br>Example: <span class="term">"BelowPlayer"</span></li><br>
				    <li><span class="term">bubbleHeight</span> - You can enter a static bubble height here if you want to. By default, this will
					be -1, which will auto compute the height of the bubble. However, bubbles have a minimum height of 40.
					<br>Example: <span class="term">150</span></li><br>
				</ul>
			</p>
			<p>
				<br><span class="function">Text.progressmode</span>
				This value is used to set the progression mode of the text: Setting it to <span class="term">"auto"</span> will make the text start a new 
				line after a  given number of frames set in <span class="term">Text.SetAutoWaitTimeBetweenFrames()</span>. Setting it to
				<span class="term">"manual"</span> will need the player to press the Confirm button at the end of each dialogue. Setting it to 
				<span class="term">"none"</span> means that you'll need to manually display the next line in-code using 
				<span class="term">Text.NextLine()</span>.
			</p>
			<p>
				<br><span class="function">Text.x</span>
				The local x position of the object, measured from the position of the text object's parent. This value depends on the object's pivot.
			</p>
			<p>
				<br><span class="function">Text.y</span>
				The local y position of the object, measured from the position of the text object's parent. This value depends on the object's pivot.
			</p>
			<p>
				<br><span class="function">Text.absx</span>
				The absolute x position of the object, measured from the bottom left corner of the screen. This value depends on the object's pivot.
			</p>
			<p>
				<br><span class="function">Text.absy</span>
				The absolute y position of the object, measured from the bottom left corner of the screen. This value depends on the object's pivot.
			</p>
			<p>
				<br><span class="function">Text.textWidth</span>
				Width of the text. If the value is lower than 16, it'll be set back to 16.
			</p>
			<p>
				<br><span class="function">Text.bubbleHeight</span>
				Height of the bubble. If the value is lower than 40, it'll be set back to 40.
			</p>
			<p>
				<br><span class="function">Text.layer</span>
				The sprite layer of the Text Object. If it doesn't exist, it returns an error. This is <span class="term">"BelowPlayer"</span> by default.
			</p>
			<p>
				<br><span class="function">Text.color</span>
				Get or set the color of the text, as a table of 3 or 4 values from 0 to 1.<br>For example, <span class="term">
				sprite.color = {1.0, 0.0, 0.0}</span> makes the text red.<br>Black areas are not affected by coloration. The 4th value is the alpha (transparency) value of the text.
			</p>
			<p>
				<br><span class="function">Text.color32</span>
				Get or set the color of the text, as a table of 3 or 4 integer values from 0 to 255.<br>For example, <span class="term">
				sprite.color = {250, 0, 0}</span> makes it red.<br>Black areas are not affected by coloration. The 4th value is the alpha (transparency) value of the text.
			</p>
			<p>
				<br><span class="function">Text.alpha</span>
				Get or set the text's transparency, as a value between 0 and 1.
			</p>
			<p>
				<br><span class="function">Text.alpha32</span>
				Get or set the text's transparency, as an integer between 0 and 255.
			</p>
			<p>
				<br><span class="function">Text.lineComplete</span>
				Returns true if the current line of text is fully displayed, false otherwise.
			</p>
			<p>
				<br><span class="function">Text.allLinesComplete</span>
				Returns true if the current line of text is fully displayed <i>and</i> if this is the last line the test object will show, false otherwise.
			</p>
			<p>
				<br><span class="function">Text.SetParent(sprite parent)</span>
				Sets the text object's parent.<br>The text object will follow around the parent object as it moves.
			</p>
			<p>
				<br><span class="function">Text.SetText(table text)</span>
				Sets the text in the Text Object.<br>If the text object is inactive when this is called, the object will reactive itself.
			</p>
			<p>
				<br><span class="function">Text.AddText(table text)</span>
				Adds the given text to the object's text table. Acts like <span class="term">Text.SetText()</span> if all the text is already done.
			</p>
			<p>
				<br><span class="function">Text.SetVoice(string fontName)</span>
				Sets the voice of the text object. It's the same as the text command <span class="term">[voice]</span>, but whatever.<br>
			</p>
			<p>
				<br><span class="function">Text.SetFont(string fontName)</span>
				Sets the font of the text. It's the same as the text command <span class="term">[font]</span>, but whatever.<br>
				Returns an error if the font doesn't exist.
			</p>
			<p>
				<br><span class="function">Text.SetEffect(string effect, float intensity)</span>
				Sets the effect of the text. Can be easily replaced be the text command <span class="term">[effect]</span>, but whatever.<br>
				Can only take <span class="term">none</span>, <span class="term">twitch</span>, <span class="term">shake</span> or
				<span class="term">twitch</span> as the effect. If you want to use the basic intensity value, enter <span class="term">-1</span>.
			</p>
			<p>
				<br><span class="function">Text.ShowBubble(string side = null, int/string position = null)</span>
				Use this function to add a bubble to the text. You can also set the side and the position of the tail (a.k.a. speech thing) if you
				want to. Look at <span class="term">Text.SetSpeechThingSideAndPosition</span> to see how to use it.
			</p>
			<p>
				<br><span class="function">Text.SetSpeechThingPositionAndSide(string side, int/string position = center)</span>
				Sets the size and position of the dialogue bubble's tail (a.k.a speech thing). The <span class="term">side</span> can only take 
				<span class="term">"left"</span>, <span class="term">"right"</span>, <span class="term">"up"</span>, <span class="term">"down"</span> or 
				<span class="term">"none"</span>.<br>
				<span class="term">"none"</span> is used to hide the speech thing, while the other directions control the side of the bubble where the 
				speech thing is.<br>
				You have two ways to set the speech thing's position (the <span class="term">center</span> argument):
				<ul>
				    <li>An int. If the <span class="term">side</span> is <span class="term">"left"</span> or <span class="term">"right"</span>, this will 
					determine its distance from the bottom of the bubble. If the <span class="term">side</span> is <span class="term">"up"</span> 
					or <span class="term">"down"</span>, then this will determine its distance from the left side of the bubble.
					<br>If on the bottom or top of the bubble, this value can only be between 0 and the bubble's width. If on the left or right sides 
					of the bubble, this value can only be between 0 and the bubble's height.</li><br>
					<li>A string. It must be formatted like <span class="term">"0%"</span>, where you can replace the "0" with any percentage. 
					If on the top or bottom of the bubble, <span class="term">"0%"</span> will be the left side of the bubble and 
					<span class="term">"100%"</span> will be the right side of the bubble. If on the left or right side, <span class="term">"0%"</span> 
					will be the bottom of the bubble and <span class="term">"100%"</span> will be the top of the bubble. The value can only be between 
					"0%" and "100%".</li><br>
				</ul>
			</p>
			<p>
				<br><span class="function">Text.HideBubble()</span>
				A function that hides the bubble.
			</p>
			<p>
				<br><span class="function">Text.NextLine()</span>
				Shows the next line (dialogue) of the text instantly, regardless of if the current one is finished or what progress mode the object has.
			</p>
			<p>
				<br><span class="function">Text.SetAutoWaitTimeBetweenTexts(int time)</span>
				Sets the number of frames to wait before automatically going to the next line of text.<br><i>Only applies to the "auto" progress mode.</i>
			</p>
			<p>
				<br><span class="function">Text.MoveTo(int x, int y)</span>
				Moves the text to a new position, relative to the text object's parent's position.
			</p>
			<p>
				<br><span class="function">Text.MoveToAbs(int x, int y)</span>
				Moves the text to a new position, relative to the bottom left corner of the window.
			</p>
			<p>
				<br><span class="function">Text.SetPivot(float x, float y)</span>
				Sets the pivot of the object. The pivot is the value where the text's position is set. The default value is 
				<span class="term">{0.5, 0.5}</span>. If you set it to <span class="term">{0, 0}</span>, then each time you modify 
				the object's position, the position will be based off of the bottom left corner of the object instead of its center. 
				<span class="term">{1, 1}</span> is the top right corner, <span class="term">{0, 1}</span> the top left corner and 
				<span class="term">{1, 0}</span> is the bottom right corner.
			</p>
		</div>		

        <div class="tab-pane text-style" id="api-projectile">
            <h2>Projectile management</h2><br><br>
            <p>Projectile management is, starting from 0.2.0, available from both the encounter and the wave scripts. As
                a result it is now in its own section.</p>
            <p>
                <br><span class="function"><span class="CYF"></span>CreateProjectileLayer(name, relatedTag = "", before = false) [E/W]</span>
				Create a projectile layer where you'll be able to put projectiles in. In order to create it, though,
				you must mention <i>another</i> projectile layer in <span class="term">relatedTag</span> - and your new layer will be created
				below that layer.<br>If <span class="term">before</span> is true, it'll be created before (above) that layer.<br>
				There is one basis layer: <span class="term">""</span> = The normal bullet layer.
            </p>

            <p>
                <br><span class="function">CreateProjectile(spritename, initial_x, initial_y,<span class="CYF"></span> layer = "") returns Bullet [E/W]</span>
                Creates a bullet that you can store and modify, with its spawn position relative to the center of the
                arena. The hitbox of the bullet is a rectangle around the sprite, unless you use CYF's PP mode.<br>
				<span class="CYF"></span> You can specify a layer if you want - otherwise, the bullet will be in the normal bullet layer.
            </p>

            <p>
                <br><span class="function">CreateProjectileAbs(spritename, initial_x, initial_y, layer = "") returns Bullet [E/W]</span>
                Same as <span class="term">CreateProjectile</span>, but the bullet's spawn position is relative to the bottom left of the screen instead of 
				the arena's center. The hitbox of the bullet is a rectangle around the sprite, unless you use CYF's PP mode.<br>
				<span class="CYF"></span> You can specify a layer if you want - otherwise, the bullet will be in the normal bullet layer.
            </p>

            <p>
                <br><span class="function">The Bullet object</span>
                This is what you use to move around the bullet and store values in it. You can store a bunch of bullets in a table
                and modify them. The functions and variables you can use on a Bullet are as follows.</p>
            <ul>
                <li><span class="term">Bullet.sprite</span> - the Bullet's sprite component. See the
					<span class="ref">Sprites &amp; Animation</span> section for usage details.
					<br>NOTE: In 0.2.1a, modifying the sprite does not change the bullet's hitbox yet; it's always
                    the original square of the bullet when it was created.
					<br><span class="CYF"></span> But, in CYF, changing the bullet's sprite <i>does</i> modify the bullet's hitbox!
                </li><br>
                <li><span class="term">Bullet.x</span> (readonly) - The X position of this bullet, relative to the arena's center. A bullet at
					<span class="term">x=0</span> and <span class="term">y=0</span> will be at the center of the arena.
                </li><br>
                <li><span class="term">Bullet.y</span> (readonly) - The Y position of this bullet, relative to the arena's center.</li><br>
                <li><span class="term">Bullet.absx</span> (readonly) - The X position of this bullet, relative to the bottom left corner of the
                    screen.
                </li><br>
                <li><span class="term">Bullet.absy</span> (readonly) - The Y position of this bullet, relative to the bottom left corner of the
                    screen.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Bullet.ppcollision</span> - Whether the bullet uses Pixel-Perfect collision.
                    If this is true, the bullet will use the Pixel-Perfect Collision system. I highly recommend for you to see
                    the <span class="ref">Pixel-Perfect Collision System</span> section if you want to use this.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Bullet.ppchanged</span> - Determines if the collision
                    system of the bullet has been set. True if it was, false otherwise.
                </li><br>
                <li><span class="CYF"></span> <span class="term">Bullet.layer</span> - The bullet layer that the bullet is on.
                </li><br>
                <li><span class="term">Bullet.isactive</span> (readonly) - Checks if the bullet is still active. If the bullet has been
                    removed, this will be false; otherwise, it will be true.
                </li><br>
                <li><span class="term">Bullet.Move(x, y)</span> - Move this bullet <span class="term">x</span> pixels to the right and
					<span class="term">y</span> pixels up. A negative <span class="term">x </span>will move it to the left, and a negative
					<span class="term">y</span> will move it downwards.
<br><span class="CYF"></span> <span style="color:#ff0000;">DEPRECATED IN CYF - USE <span class="term">Bullet.sprite.Move</span> INSTEAD</span>
                </li><br>
                <li><span class="term">Bullet.MoveTo(x, y)</span> - Move this bullet to this position immediately, relative to the arena's
                    center.
<br><span class="CYF"></span> <span style="color:#ff0000;">DEPRECATED IN CYF - USE <span class="term">Bullet.sprite.MoveTo</span> INSTEAD</span>
                </li><br>
                <li><span class="term">Bullet.MoveToAbs(x, y)</span> - Move this bullet to this position immediately, relative to the bottom left
                    corner of the screen.
<br><span class="CYF"></span> <span style="color:#ff0000;">DEPRECATED IN CYF - USE <span class="term">Bullet.sprite.MoveToAbs</span> INSTEAD</span>
                </li><br>
                <li><span class="term">Bullet.Remove()</span> - destroys this bullet. You can continue retrieving its <span class="term">x</span>, 
					<span class="term">y</span>, <span class="term">absx</span> and <span class="term">absy</span>
                    properties. Trying to move a removed bullet will give you a Lua error. If you're not sure if your
                    bullet still exists, check <span class="term">Bullet.isactive</span> first.
                </li><br>
                <li><span class="term">Bullet.SetVar(your_variable_name, value)</span> - Set a variable on this bullet that you can retrieve with
                    <span class="term">Bullet.GetVar(your_variable_name)</span>. Similar in use to <span class="term">SetGlobal()</span> - but
					you can use this to store specific variables on a per-bullet basis.
                </li><br>
                <li><span class="term">Bullet.GetVar(your_variable_name)</span> - Get a variable that you previously set using
					<span class="term">Bullet.SetVar()</span>.
                </li><br>
                <li><span class="term">Bullet.SendToTop()</span> - Moves this bullet on top of all currently existing projectiles. Note that newly
                    spawned projectiles are always on top by default; this function is mostly to move existing bullets
                    to the top.
                </li><br>
                <li><span class="term">Bullet.SendToBottom()</span> - Moves this bullet below all currently existing projectiles.</li><br>
				<li><span class="CYF"></span> <span class="term">Bullet.ResetCollisionSystem()</span> - Resets the collision system of the bullet to the 
					default one.</li><br>
				<li><span class="CYF"></span> <span class="term">Bullet.isColliding()</span> - Returns true if the player is colliding with the bullet. Will 
					use PP (pixel-perfect collisions) if the bullet has PP enabled.</li><br>
				<li><span class="CYF"></span> <span class="term">Bullet.isPersistent</span> - If you're not on retrocompatibility mode, then this
					will prevent a bullet from being automatically removed when a wave ends.</li><br>
            </ul>
            <p>Here is an example of a bullet that chases you pretty fast, but slows down as it gets closer. You have to
                keep moving to dodge it. This is a fairly basic example that makes use of the Player object.</p>
            <div class="code-container">
<pre class="brush: lua;">
oursprite = "hOI!!!!"
--Create a new bullet, starting in the upper right corner.
chasingbullet = CreateProjectile(oursprite, Arena.width/2, Arena.height/2)
--Set initial speed of 0 in both directions.
chasingbullet.SetVar('xspeed', 0)
chasingbullet.SetVar('yspeed', 0)

function Update()
	-- Get the x/y difference between the player and bullet
	local xdifference = Player.x - chasingbullet.x
	local ydifference = Player.y - chasingbullet.y
	-- We create a new speed by first halving the original speed
	-- Then we add a small fraction of the position difference between the player and bullet.
	-- The result is a bullet that moves faster as it's further away, and slower when it's closer.
	-- The value we're dividing by is experimental. Experimenting with numbers is essential!
	local xspeed = chasingbullet.GetVar('xspeed') / 2 + xdifference / 100
	local yspeed = chasingbullet.GetVar('yspeed') / 2 + ydifference / 100
	-- Now move the bullet...
	chasingbullet.Move(xspeed, yspeed)
	-- ...and store our new speeds.
	chasingbullet.SetVar('xspeed', xspeed)
	chasingbullet.SetVar('yspeed', yspeed)
end
</pre>
            </div>
            <p>Below is an example of a fully scripted Wave using most of these functions. It will spawn a projectile
                above the arena (assuming a width/height of 155/130), give it a random speed in the X direction, and
                drop it downwards. If it hits the bottom border of the arena, it'll bounce back up. Otherwise it'll
                continue falling off the screen.</p>
            <div class="code-container">
<pre class="brush: lua;">
spawntimer = 0
bullets = {}

-- This happens every frame while you're defending. --
function Update()
	spawntimer = spawntimer + 1 --Add 1 to the counter every frame

	-- This part takes care of bullet spawning. --
	if spawntimer%30 == 0 then  --This happens every 30 frames.
		local posx = 30 - math.random(60) --Set a random X position between -30 and 30
		local posy = 65 --and set the Y position to 65, on the top edge of the arena.
		local bullet = CreateProjectile('hOI!!!!', posx, posy) -- Create projectile with sprite hOI!!!!.png
		bullet.SetVar('velx', 1 - 2*math.random()) -- We'll use this for horizontal speed. Random between -1/1
		bullet.SetVar('vely', 0) -- We'll use this for fall speed. We're starting without downward movement.
		table.insert(bullets, bullet) -- Add this new Bullet object to the bullets table up there.
	end

	-- This part updates every bullet in the bullets table. --
	for i=1,#bullets do -- #bullets in Lua means 'length of bullets table'.
		local bullet = bullets[i] -- For convenience, so we don't have to use bullets[i]
		local velx = bullet.GetVar('velx') -- Get the X/Y velocity we just set
		local vely = bullet.GetVar('vely')
		local newposx = bullet.x + velx -- New position will be old position + velocity
		local newposy = bullet.y + vely
		if(bullet.x &gt; -Arena.width/2 and bullet.x &lt; Arena.width/2) then -- Are we inside the arena (horizontally)?
			if(bullet.y &lt; -Arena.height/2 + 8) then -- And did we go past the bottom edge?
				bullet.MoveTo(bullet.x, -Arena.height/2 + 8) -- Don't move it past the edge!
				-- Note the +8; I know the bullet sprite I'm using is 16x16.
				-- Without adding 8 it'll be inside the edge.
				vely = 4 --reverse bounce direction
			end
		end
		vely = vely - 0.04 -- Apply gravity
		bullet.MoveTo(newposx, newposy) -- and finally, move our bullet
		bullet.SetVar('vely', vely) -- and store our new fall speed into the bullet again.
	end
end </pre>
            </div>

            <p>
                <br><span class="function">OnHit(bullet)</span>
                Every time a bullet collides with a player, this function gets called on the script that created the
                projectile. The bullet object in this function can be modified if you feel like it. For more information
                on the bullet object, see the documentation above.<br>
                <br>
                If you implement this function in your script, you have to define manually what should happen after
                bullet collision. This is what allows you to create orange, cyan and green projectiles, and much much
                more. If you don't implement this function in your wave script, it'll stick to the default of dealing 3
                damage on hit. Below are multiple examples of how to use this function.</p>
            <div class="code-container">
  <pre class="brush:lua;">
--Defining your own damage for this wave
function OnHit(bullet)
	Player.Hurt(10)
end
 
--Replicating cyan bullet functionality
function OnHit(bullet)
	if Player.isMoving then
		Player.Hurt(5)
	end
end

--Replicating orange bullet functionality; opposite condition of cyan
function OnHit(bullet)
	if not Player.isMoving then
		Player.Hurt(5)
	end
end

--Replicating green bullet functionality
function OnHit(bullet)
	Player.Heal(1)
	bullet.Remove()
end
</pre>
            </div>
        </div>

        <div class="tab-pane text-style" id="api-animation">
            <h2>Sprites &amp; Animation</h2><br><br>
            <p>Projectile management is, starting from 0.2.0, available from both the encounter and the wave scripts. As
                a result it is now in its own section.</p>
            <p>
                <br><span class="function"><span class="CYF"></span> CreateLayer(name, relatedTag = "BasisNewest", before = false) [E/W]</span>
                Create a layer where you'll be able to put sprites. You'll choose another layer to create it, and it'll be
				created after the selected layer. If <span class="term">before</span> is true, it'll be created before this layer.<br>
				Base layers:
				<ul>
				    <li><span class="term">"Bottom"</span>: Under everything, even the background.</li><br>
				    <li><span class="term">"BelowUI"</span>: Above the background.</li><br>
				    <li><span class="term">"BelowArena"</span>: Above the background and the UI.</li><br>
				    <li><span class="term">"BelowPlayer"</span>: Above the background, the UI and the Arena.</li><br>
				    <li><span class="term">"BelowBullet"</span>: Above the background, the UI, the Arena and the Player.</li><br>
				    <li><span class="term">"Top"</span>: Above everything.</li><br>
				</ul>
            </p>
			
            <p>
                <br><span class="function">CreateSprite(spritename, <span class="CYF"></span> layer = "BelowArena") returns Sprite [E/W]</span>
                Creates a sprite in the far bottom left of the screen (at 0, 0) that you can modify in many ways.<br>
				<span class="CYF"></span> You can add a layer if you want - otherwise, the sprite will be below the arena.
            </p>

            <p>
                <br><span class="function">The Sprite object</span>
                The Sprite object has many controls intended for animation. There is a working intermediate example
                included in the Examples folder.</p>
            <ul>
                <li><span class="CYF"></span><span class="term">sprite.spritename</span> (readonly) - Returns the name of the sprite used by this 
				sprite from the <span class="term">Sprites/</span> folder.</li><br>
                <li><span class="term">sprite.x</span> - horizontal position of sprite relative to bottom left of screen, measured from its
                    pivot/anchor point (center by default). If parented, x position is relative to the parent.
                </li><br>
                <li><span class="term">sprite.y</span> - vertical position of sprite relative to bottom left of screen, measured from its
                    pivot/anchor point (center by default). If parented, y position is relative to the parent.
                </li><br>
                <li><span class="CYF"></span><span class="term">sprite.z</span> - layering position of sprite relative to bottom left of screen, measured from its
                    pivot/anchor point (center by default). If parented, z position is relative to the parent.<br><i>Only applies to the overworld.</i> 
                </li><br>
                <li><span class="term">sprite.absx</span> - horizontal position of sprite relative to bottom left of screen, ignoring its
                    pivot/anchor point and all parents.
                </li><br>
                <li><span class="term">sprite.absy</span> - vertical position of sprite relative to bottom left of screen, ignoring its
                    pivot/anchor point and all parents.
                </li><br>
                <li><span class="CYF"></span><span class="term">sprite.absz</span> - layering position of sprite relative to bottom left of screen, ignoring its
                    pivot/anchor point and all parents.<br><i>Only applies to the overworld.</i> 
                </li><br>
                <li><span class="term">sprite.xscale</span> - horizontal scaling of sprite (1.0 by default). 2.0 is twice as large, 0.5 half as
                    large.
                </li><br>
                <li><span class="term">sprite.yscale</span> - vertical scaling of sprite (1.0 by default). 2.0 is twice as large, 0.5 half as
                    large.
                </li><br>
                <li><span class="CYF"></span><span class="term">sprite.isactive</span> (readonly) - In retromode, this is <i>true</i> if a sprite has been 
				removed and <i>false</i> otherwise. If <i>not</i> in retromode, this is <i>false</i> if a sprite has been removed and <i>true</i>
				otherwise.<br></li><br>
                <li><span class="term">sprite.width</span> (readonly) - width of this sprite's image in pixels. This never changes until the
                    sprite itself is swapped.
                </li><br>
                <li><span class="term">sprite.height</span> (readonly) - height of this sprite's image in pixels. This never changes until the
                    sprite itself is swapped.
                </li><br>
                <li><span class="CYF"></span> <span class="term">sprite.animcomplete</span> - if the sprite has started an animation, this tells you if 
					the animation is complete.<br>
					If no new animation has started yet, if the loop mode is <span class="term">LOOP</span> or if the animation isn't finished, this will be 
					false. Otherwise, it will be true.</li><br>
                <li><span class="CYF"></span> <span class="term">sprite.loopmode</span> - sets the loop mode of <span class="term">SetAnimation</span> 
					functions launched after this command. Can be:
				    <ul>
					    <li><span class="term">LOOP</span> - The default mode: when the animation is finished, it plays again. <span class="term">animcomplete
							</span> is always true with this mode.</li><br>
					    <li><span class="term">ONESHOT</span> - Plays the animation once, and keeps the last frame of the animation.</li><br>
					    <li><span class="term">ONESHOTEMPTY</span> - Same as <span class="term">ONESHOT</span>, except that the last frame will be an empty 
							sprite.</li><br>
					</ul></li><br>
                <li><span class="term">sprite.color</span> - get or set the coloration of the sprite, as a table of 3 or 4 values from 0 to 1.<br>
					For example, <span class="term">sprite.color = {1.0, 0.0, 0.0}</span> colors the sprite red. This actually overlays the sprite's 
					original color, so if you want full control over the color, make sure your sprite is white. <i>Black areas are not affected by 
					coloration.</i><br><span class="CYF"></span>: The 4th value is the alpha (transparency) of the sprite.
                </li><br>
                <li><span class="CYF"></span> <span class="term">sprite.color32</span> - get or set the coloration of the sprite, as a table of 3 or 4 
					values from 0 to 255.
					<br>For example, <span class="term">sprite.color32 = {255, 0, 0}</span> colors the sprite red. This actually overlays the sprite's 
					original color, so if you want full control over the color, make sure your sprite is white. <i>Black areas are not affected by
					coloration.</i><br>The 4th value is the alpha (transparency) of the sprite.
                </li><br>
                <li><span class="term">sprite.alpha</span> - gets or sets the sprite's transparency, as a value from 0 to 1.</li><br>
                <li><span class="CYF"></span> <span class="term">sprite.alpha32</span> - gets or sets the sprite's transparency, as a vlue from 0 to 255.
				</li><br>
                <li><span class="term">sprite.rotation</span> - get or set sprite rotation, in degrees. It's clamped between 0 and 360, so if you
                    change it to 365 it becomes 5.
                </li><br>
                <li><span class="CYF"></span> <span class="term">sprite.layer</span> - the current layer of the sprite. You can set it, but if the layer 
				doesn't exists, it does nothing.<br>Default: <span class="term">"BelowArena"</span></li><br>
                <li><span class="term">sprite.Set("new_sprite")</span> - change the sprite's image. It retains its scaling and rotation. If you
                    have an animation running with <span class="term">SetAnimation</span>, the animation will override your sprite change.
                </li><br>
                <li><span class="term">sprite.SetParent(other_sprite_object)</span> - parents <span class="term">sprite</span> to <span class="term">
				other_sprite_object</span>. This will make the original sprite move along with the object it's parented to.
                </li><br>
                <li><span class="term">sprite.SetPivot(x, y)</span> - changes the point the sprite rotates/scales around; (0,0) is bottom left of
                    sprite, (1,1) is top right. You can have values outside of the 0-1 range, too.</li><br>
                <li><span class="term">sprite.SetAnchor(x, y)</span> - change the point your sprite anchors to when moving. Mainly noticeable when
                    rescaling the parent sprite, and you want to have this sprite stick to a certain edge of it. x/y
                    should be in 0-1 range.</li><br>
                <li><span class="term">sprite.MoveTo(x, y)</span> - same as setting x and y simultaneously.</li><br>
                <li><span class="term">sprite.MoveToAbs(x, y)</span> - used to move a sprite to an absolute screen position, regardless of parent
                    settings. The sprite itself will remain parented.</li><br>
                <li><span class="term">sprite.Scale(xscale, yscale)</span> - same as setting xscale and yscale simultaneously</li><br>
                <li><span class="term">sprite.SetAnimation(sprite_table)</span> to do frame-by-frame animation at 30FPS. Example:
                    <span class="term">sprite.SetAnimation({"sans_head1", "sans_head2", "sans_head3"})</span>
					<br><span class="CYF"></span> In CYF, it can use sprites with different sizes!
                </li><br>
                <li><span class="term">sprite.SetAnimation(sprite_table, time_per_frame)</span> Performs frame-by-frame animation with your own time
                    between frames, in seconds. If <span class="term">time_per_frame</span> is 1, it takes 1 second to move to the next sprite.
					<br><span class="CYF"></span> Now it can use sprites with different sizes!
                </li><br>
                <li><span class="term">sprite.StopAnimation()</span> - stop the frame-by-frame animation if it was running. Also changes back to
                    the sprite it had before the animation, or whenever you last called <span class="term">sprite.Set()</span>.
                </li><br>
                <li><span class="term">sprite.SendToTop()</span> - sends this sprite to the top of its layer's hierarchy. If a sprite has 5
                    children, for instance, you can use this to rearrange them internally. However, child sprites will
                    always appear on top of their parents, regardless of this function being called.
                </li><br>
                <li><span class="term">sprite.SendToBottom()</span> sends this sprite to the bottom of its layer's hierarchy. Similar rules apply
                    as with <span class="term">SendToTop()</span>.
                </li><br>
                <li><span class="CYF"></span> <span class="term"> sprite.MoveBelow(other_sprite_object)</span> - if the two sprites have the same parent, 
					it'll move this sprite just below the other sprite.
                </li><br>
                <li><span class="CYF"></span> <span class="term"> sprite.MoveAbove(other_sprite_object)</span> - if the two sprites have the same parent, 
					it'll move this sprite just above the other sprite.
                </li><br>
                <li><span class="term">sprite.Remove()</span> - removes the sprite. Calling anything other than <span class="term">isactive</span> after 
					this will give you an error.
                </li><br>
                <li><span class="CYF"></span> <span class="term">sprite.Dust(playDust = true, removeObject = false)</span> - Turns a sprite into dust, just
					like what happens in Undertale when an enemy is killed. Will remove a bullet or sprite if <span class="term">removeObject</span> is set 
					to true. Set <span class="term">playSound</span> to false to deactivate the dust sound.
                </li><br>

            </ul>
            <p>The animation script used in the example is shown below for reference.</p>
            <div class="code-container">
<pre class="brush: lua;">
-- First, we can create the torso, legs and head.
sanstorso = CreateSprite("sans/sanstorso")
sanslegs = CreateSprite("sans/sanslegs")
sanshead = CreateSprite("sans/sanshead1")

--We parent the torso to the legs, so when you move the legs, the torso moves too.
--We do the same for attaching the head to the torso.
sanstorso.SetParent(sanslegs)
sanshead.SetParent(sanstorso)

--Now we adjust the height for the individual parts so they look more like a skeleton and less like a pile of bones.
sanslegs.y = 240
sanstorso.y = -5 --The torso's height is relative to the legs they're parented to.
sanshead.y = 40 --The head's height is relative to the torso it's parented to.

--We set the torso's pivot point to halfway horizontally, and on the bottom vertically,
--so we can rotate it around the bottom instead of the center.
sanstorso.SetPivot(0.5, 0)

--We set the torso's anchor point to the top center. Because the legs are pivoted on the bottom (so rescaling them only makes them move up),
--we want the torso to move along upwards with them.
sanstorso.SetAnchor(0.5, 1)
sanslegs.SetPivot(0.5, 0)

--Finally, we do some frame-by-frame animation just to show off the feature. You put in a list of sprites,
--and the time you want a sprite change to take. In this case, it's 1/2 of a second.
sanshead.SetAnimation({"sans/sanshead1", "sans/sanshead2", "sans/sanshead3"}, 1/2)

function AnimateSans()
	sanslegs.Scale(1, 1+0.1*math.sin(Time.time*2))
	sanshead.MoveTo(2*math.sin(Time.time), 40 + 2*math.cos(Time.time))
	sanshead.rotation = 10*math.sin(Time.time + 1)
	sanstorso.rotation = 10*math.sin(Time.time + 2)
end
</pre>
            </div>

        </div>

        <div class="tab-pane text-style" id="mercy">
            <h2 style="text-decoration: none; line-height:50px;">
                * YOU WON!<br>
                * You earned 0 EXP and 0 gold.<br>
                * also the nav menu is broken now
            </h2><br>
        </div>

    </div>
</div>

<div class="container">
    <div class="col-xs-3"><img class="centerbt black" alt="Undertale fake button" src="img/fightbt_0.png" height="42">
    </div>
    <div class="col-xs-3"><img class="centerbt black" alt="Undertale fake button" src="img/actbt_0.png" height="42">
    </div>
    <div class="col-xs-3"><img class="centerbt black" alt="Undertale fake button" src="img/itembt_0.png" height="42">
    </div>
    <div class="col-xs-3"><a href="#mercy" data-toggle="tab"><img class="centerbt black" alt="Undertale fake button"
                                                                  src="img/mercybt_0.png" height="42"></a>
    </div>
</div>
<br>
<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script type="text/javascript" src="js/show_hide_comments.js"></script>
</body>
</html>